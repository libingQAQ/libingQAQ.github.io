<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>初学java-JDBC</title>
    <link href="/2020/01/17/%E5%88%9D%E5%AD%A6java-JDBC/"/>
    <url>/2020/01/17/%E5%88%9D%E5%AD%A6java-JDBC/</url>
    
    <content type="html"><![CDATA[<p>初学java-JDBC所做小结</p><a id="more"></a><h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><p>　* JDBC（Java Data Base Connectivity,java数据库连接）是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。是Java访问数据库的标准规范<br>　* JDBC提供了一种基准,据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序。<br>　* DBC需要连接驱动，驱动是两个设备要进行通信，满足一定通信数据格式，数据格式由设备提供商规定，设备提供商为设备提供驱动软件，通过软件可以与该设备进行通信。<br>　* Java提供访问数据库规范称为JDBC，而生产厂商提供规范的实现类称为驱动。JDBC是接口，驱动是接口的实现类，没有驱动将无法完成数据库连接，从而不能操作数据库！每个数据库厂商都需要提供自己的驱动，用来连接自己公司的数据库，也就是说驱动一般都由数据库生成厂商提供。</p><h3 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h3><p>　1. 初始化驱动.<br>　　　告知JVM使用的是哪一个数据库的驱动<br>　2. 建立连接.<br>     使用JDBC中的类，完成对MySQL数据库的连接<br>　3. 获得语句执行平台,执行sql语句<br>　　　通过连接对象获取对SQL语句的执行者对象,使用执行者对象，向数据库执行SQL语句  获取到数据库的执行后的结果<br>　4. 处理结果<br>　5. 释放资源.</p><h4 id="初始化驱动"><a href="#初始化驱动" class="headerlink" title="初始化驱动"></a>初始化驱动</h4><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;        Class.forName(<span class="hljs-string">"com.mysql.jdbc.Driver"</span>);        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;             e.printStackTrace();        &#125;&#125;</code></pre><p>初始化驱动类com.mysql.jdbc.Driver，该类就在 mysql-connector-java-5.0.8-bin.jar中。如果你使用的是oracle数据库那么该驱动类将不同。<br>Class.forName是把这个类加载到JVM中，加载的时候，就会执行其中的静态初始化块，完成驱动的初始化的相关工作。</p><h4 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h4><pre><code class="hljs java">Connection conn = DriverManager.getConnection(<span class="hljs-string">"jdbc:mysql://localhost:3306/demo"</span>, <span class="hljs-string">"root"</span>, <span class="hljs-string">"1234"</span>);</code></pre><p>1.这里连接的是本地数据库 localhost<br>2.Mysql数据库的端口号：3306<br>3.数据库表名 demo（填自己的数据库表名）<br>4.账号  （填写自己的账号）<br>5.密码  （填写自己的密码）</p><p>Connection是与特定数据库连接回话的接口，使用的时候需要导包，而且必须在程序结束的时候将其关闭。getConnection方法也需要捕获SQLException异常。</p><h4 id="创建Statement或者PreparedStatement接口-执行语句"><a href="#创建Statement或者PreparedStatement接口-执行语句" class="headerlink" title="创建Statement或者PreparedStatement接口,执行语句"></a>创建Statement或者PreparedStatement接口,执行语句</h4><ul><li><p>Statement接口：</p><pre><code class="hljs java">Statement s = conn.createStatement();<span class="hljs-comment">// 准备sql语句</span><span class="hljs-comment">// 注意： 字符串要用单引号'</span>String name = <span class="hljs-string">"二狗"</span>;String sql = <span class="hljs-string">"insert into user(id,uname) values ("</span>+<span class="hljs-number">1</span>+<span class="hljs-string">",'"</span>+name+<span class="hljs-string">"')"</span>;<span class="hljs-comment">//在statement中使用字符串拼接的方式，这种方式存在诸多问题</span>s.execute(sql);System.out.println(<span class="hljs-string">"执行插入语句成功"</span>);</code></pre><p>Statement接口创建之后，可以执行SQL语句，完成对数据库的增删改查。其中 ，增删改只需要改变SQL语句的内容就能完成，然而查询略显复杂。<br>字符串拼接方式的SQL语句是非常繁琐的，中间有很多的单引号和双引号的混用，极易出错</p></li><li><p>PreparedStatemet接口：</p><pre><code class="hljs java">String sql = <span class="hljs-string">"insert into user (id,uname,pwd,regTime) values (?,?,66666,?)"</span>; <span class="hljs-comment">//该语句为每个 IN 参数保留一个问号（“？”）作为占位符</span>PreparedStatement ps = coon.preparedStatemtent(sql);ps.setObject(<span class="hljs-number">1</span>, <span class="hljs-string">"123"</span>); <span class="hljs-comment">//给占位符赋值</span>ps.setObject(<span class="hljs-number">2</span>, <span class="hljs-string">"麻子"</span>); <span class="hljs-comment">//给占位符赋值</span>ps.setObject(<span class="hljs-number">3</span>, <span class="hljs-keyword">new</span> java.sql.Date(System.currentTimeMillis()));  <span class="hljs-comment">//给占位符赋值</span>ps.execute(); <span class="hljs-comment">//执行</span></code></pre><p>使用PreparedStatement时，他的SQL语句不再采用字符串拼接的方式，而是采用占位符的方式。“？”在这里就起到占位符的作用。这种方式除了避免了statement拼接字符串的繁琐之外，还能够提高性能。每次SQL语句都是一样的，java类就不会再次编译，这样能够显著提高性能。</p></li></ul><p><strong>Statement和PreparedStatement的异同及优缺点</strong><br>同：两者都是用来执SQL语句的<br>异：PreparedStatement需要根据SQL语句来创建，它能够通过设置参数，指定相应的值，不是像Statement那样使用字符串拼接的方式。</p><p><strong>PreparedStatement的优点：</strong><br>1、其使用参数设置，可读性好，不易记错。在statement中使用字符串拼接，可读性和维护性比较差。<br>2、其具有预编译机制，性能比statement更快。<br>3、其能够有效防止SQL注入攻击。</p><h4 id="处理结果"><a href="#处理结果" class="headerlink" title="处理结果"></a>处理结果</h4><pre><code class="hljs java">String sql = <span class="hljs-string">"select id,uname,pwd from user where id&gt;?"</span>;PrepareStatement ps = conn.prepareStatement(sql);ps.setObject(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">//把id大于2的记录都取出来</span>ResultSet rs = ps.executeQuery();<span class="hljs-keyword">while</span>(rs.next()) &#123;System.out.println(rs.getInt(<span class="hljs-string">"id"</span>)+<span class="hljs-string">"--"</span>+rs.getString(<span class="hljs-string">"uname"</span>));&#125;</code></pre><p>利用While(ResultSet.next()){…}循环将集合ResultSet中的结果遍历出来。</p><p>ResultSet.getXX();     这里的get方法的括号里面可以填属性值，如下图代码中的course_id,还可以填该属性在数据表中的列号，从1开始编码，例如：course_id在我的t-courses数据表中位于第一列，所以执行get方法的时候，我除了代码段中写法外，还可以这样写int courseId = rs.getInt(1);但是不推荐使用列号的这种方式，因为一段数据表中个属性值得顺序发生变化，就会导致这里出错，而使用属性名则不会出现这样的问题。</p><h4 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h4><p>在JDBC编码的过程中我们创建了Connection、ResultSet等资源，这些资源在使用完毕之后是一定要进行关闭的。关闭的过程中遵循从里到外的原则。</p>]]></content>
    
    
    
    <tags>
      
      <tag>初学java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GOF32</title>
    <link href="/2020/01/16/GOF32-%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/01/16/GOF32-%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><ul><li>分离了对象子组件的单独构造（由 Builder 来负责）和装配（由 Director 负责）。从而可以构造出复杂的对象。这个模式适用于：某个对象的构建过程复杂的情况下使用。</li><li>由于时下按了构建和装配的解耦。不同的构建起，相同的装配，也可以做出不同的对象；相同的构建起，不同的装配顺序也可以做出不同的对象。也就算实现了构建算法、装配算法的解耦，实现了更好的复用。</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AirShip</span> </span>&#123;<span class="hljs-keyword">private</span> OrbitalModule orbitalModule; <span class="hljs-comment">// 轨道舱</span><span class="hljs-keyword">private</span> Engine engine; <span class="hljs-comment">// 发动机</span><span class="hljs-keyword">private</span> EscapeTower escapeTower; <span class="hljs-comment">// 逃逸塔</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">launch</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"发射！"</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> OrbitalModule <span class="hljs-title">getOrbitalModule</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> orbitalModule;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setOrbitalModule</span><span class="hljs-params">(OrbitalModule orbitalModule)</span> </span>&#123;<span class="hljs-keyword">this</span>.orbitalModule = orbitalModule;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> Engine <span class="hljs-title">getEngine</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> engine;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEngine</span><span class="hljs-params">(Engine engine)</span> </span>&#123;<span class="hljs-keyword">this</span>.engine = engine;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> EscapeTower <span class="hljs-title">getEscapeTower</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> escapeTower;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEscapeTower</span><span class="hljs-params">(EscapeTower escapeTower)</span> </span>&#123;<span class="hljs-keyword">this</span>.escapeTower = escapeTower;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrbitalModule</span> </span>&#123;<span class="hljs-keyword">private</span> String name;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OrbitalModule</span><span class="hljs-params">(String name)</span> </span>&#123;<span class="hljs-keyword">this</span>.name = name;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> name;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<span class="hljs-keyword">this</span>.name = name;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Engine</span> </span>&#123;<span class="hljs-keyword">private</span> String name;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Engine</span><span class="hljs-params">(String name)</span> </span>&#123;<span class="hljs-keyword">this</span>.name = name;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> name;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<span class="hljs-keyword">this</span>.name = name;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EscapeTower</span> </span>&#123;<span class="hljs-keyword">private</span> String name;<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> name;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<span class="hljs-keyword">this</span>.name = name;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EscapeTower</span><span class="hljs-params">(String name)</span> </span>&#123;<span class="hljs-keyword">super</span>();<span class="hljs-keyword">this</span>.name = name;&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AirShipBuilder</span> </span>&#123;<span class="hljs-function">Engine <span class="hljs-title">builderEngine</span><span class="hljs-params">()</span></span>;<span class="hljs-function">OrbitalModule <span class="hljs-title">builderOrbitalModule</span><span class="hljs-params">()</span></span>;<span class="hljs-function">EscapeTower <span class="hljs-title">builderEscapeTower</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AirShipDirector</span> </span>&#123;<span class="hljs-comment">/** * 组装飞船对象 * <span class="hljs-doctag">@return</span> */</span><span class="hljs-function">AirShip <span class="hljs-title">directAirShip</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbinAirShipBuilder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AirShipBuilder</span> </span>&#123;<span class="hljs-comment">//StringBuilder, 以后学习XML解析中，JDOM库中的类：DomBuilder,SaxBuilder</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Engine <span class="hljs-title">builderEngine</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"构建发动机！"</span>);<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Engine(<span class="hljs-string">"Abin发动机！"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> EscapeTower <span class="hljs-title">builderEscapeTower</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"构建逃逸塔"</span>);<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> EscapeTower(<span class="hljs-string">"Abin逃逸塔"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> OrbitalModule <span class="hljs-title">builderOrbitalModule</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"构建轨道舱"</span>);<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> OrbitalModule(<span class="hljs-string">"Abin轨道舱"</span>);&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbinAirshipDirector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AirShipDirector</span> </span>&#123;<span class="hljs-keyword">private</span> AirShipBuilder builder;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AbinAirshipDirector</span><span class="hljs-params">(AirShipBuilder builder)</span> </span>&#123;<span class="hljs-keyword">this</span>.builder = builder;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> AirShip <span class="hljs-title">directAirShip</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//装配成飞船对象</span>AirShip ship = <span class="hljs-keyword">new</span> AirShip();ship.setEngine(builder.builderEngine());ship.setEscapeTower(builder.builderEscapeTower());ship.setOrbitalModule(builder.builderOrbitalModule());<span class="hljs-keyword">return</span> ship;&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        AirShipDirector director=<span class="hljs-keyword">new</span> AbinAirshipDirector(<span class="hljs-keyword">new</span> AbinAirShipBuilder());        AirShip ship = director.directAirShip();        System.out.println(ship.getEngine().getName());    &#125;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>GOF32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GOF32-工厂模式</title>
    <link href="/2020/01/15/GOF32-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/01/15/GOF32-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>GOF32-工厂模式</p><a id="more"></a><h3 id="面向对象设计的基本原则："><a href="#面向对象设计的基本原则：" class="headerlink" title="面向对象设计的基本原则："></a>面向对象设计的基本原则：</h3><ul><li>OCP（开闭原则，Open-Closed Principle）：一个软件的实体应当对扩展开放，对修改关闭。</li><li>DIP（依赖倒转原则，Dependence Inversion Principle）：要针对接口编程，不要针对实现编程。</li><li>LoD（迪米特法则，Law of Demeter）：只与你直接的朋友通信，而避免和陌生人通信。<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3>实现了创建者和调用者的分离<br>有简单工厂，工厂方法，抽象工厂</li></ul><h4 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h4><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Car</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Audi</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Car</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"我是奥迪！"</span>);&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Byd</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Car</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"我是比亚迪！"</span>);&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CarFactory</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Car <span class="hljs-title">createCar</span><span class="hljs-params">(String type)</span> </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-string">"奥迪"</span>.equals(type)) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Audi();&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"比亚迪"</span>.equals(type)) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Byd();&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client02</span> </span>&#123; <span class="hljs-comment">// 调用者</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;CarFactory.createCar(<span class="hljs-string">"奥迪"</span>).run();CarFactory.createCar(<span class="hljs-string">"比亚迪"</span>).run();&#125;&#125;</code></pre><h4 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h4><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Car</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Audi</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Car</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"我是奥迪！"</span>);&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Byd</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Car</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"我是比亚迪！"</span>);&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CarFactory</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> Car <span class="hljs-title">createCar</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AudiFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CarFactory</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Car <span class="hljs-title">createCar</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Audi();&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BydFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CarFactory</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Car <span class="hljs-title">createCar</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Byd();&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">new</span> AudiFactory().createCar().run();<span class="hljs-keyword">new</span> BydFactory().createCar().run();&#125;&#125;</code></pre><h4 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h4><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Engine</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LuxuryEngine</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Engine</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"转的快！"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"启动快!可以自动启停！"</span>);&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LowEngine</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Engine</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"转的慢！"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"启动慢!"</span>);&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Seat</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">massage</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LuxurySeat</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Seat</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">massage</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"可以自动按摩！"</span>);&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LowSeat</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Seat</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">massage</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"不能按摩！"</span>);&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Tyre</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">revolve</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LuxuryTyre</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Tyre</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">revolve</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"旋转不磨损！"</span>);&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LowTyre</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Tyre</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">revolve</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"旋转磨损快！"</span>);&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CarFactory</span> </span>&#123;<span class="hljs-function">Engine <span class="hljs-title">createEngine</span><span class="hljs-params">()</span></span>;<span class="hljs-function">Seat <span class="hljs-title">createSeat</span><span class="hljs-params">()</span></span>;<span class="hljs-function">Tyre <span class="hljs-title">createTyre</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LuxuryCarFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CarFactory</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Engine <span class="hljs-title">createEngine</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LuxuryEngine();&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Seat <span class="hljs-title">createSeat</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LuxurySeat();&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Tyre <span class="hljs-title">createTyre</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LuxuryTyre();&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LowCarFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CarFactory</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Engine <span class="hljs-title">createEngine</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LowEngine();&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Seat <span class="hljs-title">createSeat</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LowSeat();&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Tyre <span class="hljs-title">createTyre</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LowTyre();&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;CarFactory factory = <span class="hljs-keyword">new</span> LuxuryCarFactory();Engine engine = factory.createEngine();Seat seat = factory.createSeat();Tyre tyre = factory.createTyre();&#125;&#125;</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>简单工厂模式：虽然某种程度不符合设计原则，但实际使用最多</li><li>工厂方法模式：不修改已有类的前提下，通过增加新的工厂类实现扩展。</li><li>抽象工厂模式：不可以增加产品，可以增加产品族</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>JDK 中 Calendar 的 getInstance 方法</li><li>JDBC 中 Connection 对象的获取</li><li>Hibernate 中 SessionFactory 创建 Session</li><li>Spring 中 IOC 容器创建管理 bean对象</li><li>XML 解析时的 DocumentBuilderFactory 创建解析器对象</li><li>反射中 Class 对象的 newInstance()</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>GOF32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GOF32-单例模式</title>
    <link href="/2020/01/14/GOF32-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/01/14/GOF32-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>GOF32-单例模式</p><a id="more"></a><h3 id="单利模式"><a href="#单利模式" class="headerlink" title="单利模式"></a>单利模式</h3><ul><li>保证一个类只有一个实例，并且提供一个访问该实例的全局访问点。</li><li>由于单例模式只生成一个实例，减少了系统性能开销。单例模式可以在系统设置全局的访问点，优化共享资源访问。例如可以设计一个单例类，负责所有数据表的映射处理。</li></ul><h3 id="常见五种单例模式"><a href="#常见五种单例模式" class="headerlink" title="常见五种单例模式"></a>常见五种单例模式</h3><p>饿汉式，懒汉式，双重检测锁，静态内部类，枚举单例。</p><h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><p>线程安全，调用效率高，但不能不能延时加载</p><pre><code class="hljs java"><span class="hljs-comment">/** * 测试饿汉式单例模式 * <span class="hljs-doctag">@author</span> Abin */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonDemo1</span> </span>&#123;<span class="hljs-comment">//类初始化时，立即加载这个对象(没有延时加载的优势)。加载类时，天然的是线程安全的！</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingletonDemo1 instance = <span class="hljs-keyword">new</span> SingletonDemo1();<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonDemo1</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// 私有化构造器</span>&#125;<span class="hljs-comment">//方法没有同步，调用效率高！</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonDemo1  <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> instance;&#125;&#125;</code></pre><h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><p>线程安全，调用小路不高，可以延时加载。</p><pre><code class="hljs java"><span class="hljs-comment">/** * 测试懒汉式单例模式 * <span class="hljs-doctag">@author</span> Abin */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonDemo2</span> </span>&#123;<span class="hljs-comment">//类初始化时，不初始化这个对象（延时加载，真正用的时候再创建）。</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingletonDemo2 instance;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonDemo2</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 私有化构造器</span>&#125;<span class="hljs-comment">//方法同步，调用效率低！</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> SingletonDemo2 <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;instance = <span class="hljs-keyword">new</span> SingletonDemo2();&#125;<span class="hljs-keyword">return</span> instance;&#125;&#125;</code></pre><h4 id="双重检测锁"><a href="#双重检测锁" class="headerlink" title="双重检测锁"></a>双重检测锁</h4><p>由于JVM底层内部模型原因，偶尔会出现问题，不建议使用</p><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>线程安全，调用效率高，可以延时加载。</p><pre><code class="hljs java"><span class="hljs-comment">/** * 测试静态内部类实现单例模式 这种方式：线程安全，调用效率高，并且实现了延时加载！ * <span class="hljs-doctag">@author</span> Abin * */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonDemo4</span> </span>&#123; <span class="hljs-comment">//使用一个静态的内部类来创建实例，SingletonClassInstance.getInstance时才会初始化</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonClassInstance</span> </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> SingletonDemo4 instance = <span class="hljs-keyword">new</span>   SingletonDemo4();&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonDemo4</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//私有化构造方法</span>&#125;<span class="hljs-comment">//方法没有同步，调用效率高！</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonDemo4 <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> SingletonClassInstance.instance;&#125;&#125;</code></pre><h4 id="枚举单例"><a href="#枚举单例" class="headerlink" title="枚举单例"></a>枚举单例</h4><p>线程安全、调用效率高，不能延时加载（天然防治反射和反序列化的漏洞）</p><pre><code class="hljs java"><span class="hljs-comment">/** * 测试枚举式实现单例模式(没有延时加载) * <span class="hljs-doctag">@author</span> Abin */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> SingletonDemo5 &#123;<span class="hljs-comment">//这个枚举元素，本身就是单例对象！</span>INSTANCE;<span class="hljs-comment">//添加自己需要的操作！</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">singletonOperation</span><span class="hljs-params">()</span> </span>&#123;&#125;&#125;</code></pre><h3 id="破解单例模式"><a href="#破解单例模式" class="headerlink" title="破解单例模式"></a>破解单例模式</h3><h4 id="反射破解单例模式"><a href="#反射破解单例模式" class="headerlink" title="反射破解单例模式"></a>反射破解单例模式</h4><pre><code class="hljs java"><span class="hljs-comment">/** * 测试反射破解单例模式（静态内部类法） * <span class="hljs-doctag">@author</span> Abin */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client2</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;SingletonDemo4 s1 = SingletonDemo4.getInstance();SingletonDemo4 s2 = SingletonDemo4.getInstance();System.out.println(s1 == s2); <span class="hljs-comment">// true;</span><span class="hljs-comment">//通过反射的方式直接调用私有构造器</span>Class clazz = Class.forName(<span class="hljs-string">"com.bjsxt.singleton.SingletonDemo4"</span>);Constructor c = clazz.getDeclaredConstructor(<span class="hljs-keyword">null</span>);c.setAccessible(<span class="hljs-keyword">true</span>);SingletonDemo4  s3 = (SingletonDemo4) c.newInstance();SingletonDemo4  s4 = (SingletonDemo4) c.newInstance();System.out.println(s3 == s4);  <span class="hljs-comment">//false</span>&#125;</code></pre><h4 id="反序列化破解单例模式"><a href="#反序列化破解单例模式" class="headerlink" title="反序列化破解单例模式"></a>反序列化破解单例模式</h4><pre><code class="hljs java"><span class="hljs-comment">/** * 测试反序列化破解单例模式（静态内部类法） * <span class="hljs-doctag">@author</span> Abin */</span>SingletonDemo4 s1 = SingletonDemo4.getInstance();SingletonDemo4 s1 = SingletonDemo4.getInstance();SingletonDemo4 s2 = SingletonDemo4.getInstance();System.out.println(s1 == s2); <span class="hljs-comment">// true;</span><span class="hljs-comment">//将s1序列化保存</span>FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">"d:/a.txt"</span>);ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(fos);oos.writeObject(s1);oos.close();fos.close();<span class="hljs-comment">//通过反序列化的方式构造多个对象 </span>ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"d:/a.txt"</span>));SingletonDemo4 s2 = (SingletonDemo4) ois.readObject();System.out.println(s1==s3); <span class="hljs-comment">// false</span></code></pre><h3 id="防止反射与反序列化的漏洞"><a href="#防止反射与反序列化的漏洞" class="headerlink" title="防止反射与反序列化的漏洞"></a>防止反射与反序列化的漏洞</h3><pre><code class="hljs java"><span class="hljs-comment">/** * 测试懒汉式单例模式(如何防止反射和反序列化漏洞) * <span class="hljs-doctag">@author</span> Abin */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonDemo6</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<span class="hljs-comment">//类初始化时，不初始化这个对象（延时加载，真正用的时候再创建）。</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingletonDemo6 instance;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonDemo6</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 私有化构造器</span><span class="hljs-keyword">if</span> (instance != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">//构造器中抛出异常</span><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException();  &#125;<span class="hljs-comment">//方法同步，调用效率低！</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> SingletonDemo6 <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;instance = <span class="hljs-keyword">new</span> SingletonDemo6();&#125;<span class="hljs-keyword">return</span> instance;&#125;<span class="hljs-comment">//反序列化时，如果定义了readResolve()则直接返回此方法指定的对象。而不需要单独再创建新对象！</span><span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">readResolve</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ObjectStreamException </span>&#123;<span class="hljs-keyword">return</span> instance;&#125;&#125;</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>当需要单例对象，占用资源少，不需要延时加载时，枚举式优于饿汉式</li><li>当需要单例对象，占用资源少，需要延时加载时，静态内部类优于懒汉式</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>Windows的Task Manager(任务管理器)</li><li>Windows的Recycle Bin(回收站)</li><li>应用程序的日志应用</li><li>数据库连接池</li><li>操作系统的文件系统，一个操作系统只能有一个文件系统</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>GOF32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java类加载机制</title>
    <link href="/2019/12/31/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <url>/2019/12/31/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>浅谈Java类加载机制，虚拟机如何加载Class文件。</p><a id="more"></a><p>先贴出一段代码，请思考一下输出结果</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> Java;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassOfLoading</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Son s = <span class="hljs-keyword">new</span> Son();&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span></span>&#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> f  ;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Son son = <span class="hljs-keyword">new</span> Son();<span class="hljs-keyword">static</span> &#123;f = <span class="hljs-number">10</span>;System.out.println(<span class="hljs-string">"Father静态块 ,f="</span> + f);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Father</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"Father构造器 ,f="</span> + f);&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span></span>&#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> s;<span class="hljs-keyword">static</span> &#123;s = <span class="hljs-number">12</span>;System.out.println(<span class="hljs-string">"Son静态块 ,s="</span> + s);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Son</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"Son构造器 ,s="</span> + s);&#125;&#125;</code></pre><h3 id="java虚拟机类加载机制"><a href="#java虚拟机类加载机制" class="headerlink" title="java虚拟机类加载机制"></a>java虚拟机类加载机制</h3><p>虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。<br>在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，所以Java可以动态扩展的语言特性(c++是静态语言)就是依赖运行期动态加载和动态链接这个特点实现的。</p><h3 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h3><p>类的生命周期(从被加载到虚拟机内存开始，到卸载出内存为止)有七个阶段：<br>加载，验证，准备，解析，初始化，使用，卸载</p><p>加载，验证，准备，初始化，卸载 的顺序是确定的，必须按这个流程开始(只是开始！！！)。</p><p>java虚拟机规范中没有强制约束什么情况下需要开始 加载。但是严格规定了有且只有五种情况必须立即对类进行 初始化 (那么加载，验证，准备一定会在此之前开始)：</p><ol><li>遇到new，getstatic，putstatic，invakestatic 这4条字节码指令时，如果类没有进行初始化，则需要先触发初始化。也就是使用new关键字实例化对象的时候，读取,设置一个类的静态字段的时候，以及调用一个类的静态方法时。</li><li>当虚拟机启动时，会初始化主类（包含main()方法的类）<br>（省略以下3条）</li></ol><h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3>]]></content>
    
    
    
    <tags>
      
      <tag>“Java”</tag>
      
      <tag>类加载机制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初学Java-多线程</title>
    <link href="/2019/12/16/%E5%88%9D%E5%AD%A6Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2019/12/16/%E5%88%9D%E5%AD%A6Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>看完 <a href="https://www.cnblogs.com/xiaoxi/" target="_blank" rel="noopener">平凡希</a> 大佬的<a href="https://www.cnblogs.com/xiaoxi/p/7581899.html" target="_blank" rel="noopener">《java多线程基础总结》</a> ，结合总结的所学，写出的一篇关于java多线程基础的文章</p><a id="more"></a><h3 id="多线程基础"><a href="#多线程基础" class="headerlink" title="多线程基础"></a>多线程基础</h3><h4 id="一、程序，进程，线程"><a href="#一、程序，进程，线程" class="headerlink" title="一、程序，进程，线程"></a>一、程序，进程，线程</h4><ul><li><strong>程序：</strong> 一组指令的有序集合，是静态的实体。</li><li><strong>进程：</strong> 系统进行资源分配的基本单位，是程序在某个数据集上的执行，进程 = 程序 + 数据集 + 进程控制块。</li><li><strong>线程：</strong> 系统进行调度的最小单位，共享进程的资源，是程序中一个单一的控制流程，在单个程序中同时运行多个线程完成不同的工作，称为多线程。</li></ul><hr><h4 id="二、线程状态"><a href="#二、线程状态" class="headerlink" title="二、线程状态"></a>二、线程状态</h4><ul><li><strong>初始状态(NEW)：</strong> 当线程创建后，但还没有调用start()方法。</li><li><strong>运行状态(RUNNABLE)：</strong>java线程中将就绪(ready)和运行中(running)这两种状态统称为“运行”。当线程对象创建后，其他线程调用该对象的start()方法,改线程处于可以运行线程池中，等待cpu随机调度。</li><li><strong>阻塞状态(BLOCKED)：</strong>线程阻塞于锁。</li><li><strong>等待(WAITING)：</strong>进入该状态的线程正在等待另一个线程执行特定动作（通知或中断）</li><li><strong>超时等待(TIMED_WAITING)：</strong>该状态不同于WAITING，它可以在指定的时间后自行返回。</li><li><strong>终止(TERMINATED)：</strong>表示该线程已经执行完毕。</li></ul><p><img src="E:%5CimageForBolg%5CThreadState.jpg" srcset="/img/loading.gif" alt="ThreadState"></p><hr><h4 id="三、创建多线程"><a href="#三、创建多线程" class="headerlink" title="三、创建多线程"></a>三、创建多线程</h4><h5 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h5><p><strong>重写run()方法：</strong> 如果继承了Thread类，那么就不能继承其他的类。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;                                                                                                                                   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(String name)</span></span>&#123;<span class="hljs-keyword">super</span>(name);<span class="hljs-comment">//重写构造，可以对线程添加名字</span>&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)&#123;System.out.println(Thread.currentThread().getName());            <span class="hljs-comment">//输出当前线程的名字</span>&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        MyThread mt = <span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">"test"</span>);        System.out.println(Thread.currentThread().getName());        <span class="hljs-comment">//输出当前线程的名字 --- main</span>        mt.start();            &#125;&#125;</code></pre><hr><h5 id="实现Runable接口"><a href="#实现Runable接口" class="headerlink" title="实现Runable接口"></a>实现Runable接口</h5><p><strong>实现run方法：</strong> 解决继承Thread的缺点，没有返回值.</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RunableTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            System.out.println(<span class="hljs-string">"good time"</span>);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        RunableTest runableTest1 = <span class="hljs-keyword">new</span> RunableTest();        RunableTest runableTest2 = <span class="hljs-keyword">new</span> RunableTest();        <span class="hljs-keyword">new</span> Thread(runableTest1).start();        <span class="hljs-keyword">new</span> Thread(runableTest1).start();        <span class="hljs-keyword">new</span> Thread(runableTest2).start();    &#125;&#125;</code></pre><h5 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h5><p><strong>实现run方法：</strong> </p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello world"</span>;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        FutureTask&lt;String&gt; futureTask = <span class="hljs-keyword">new</span> FutureTask&lt;String&gt;(<span class="hljs-keyword">new</span> CallTest());        <span class="hljs-keyword">new</span> Thread(futureTask).start();        <span class="hljs-keyword">try</span> &#123;            String result = futureTask.get();            System.out.println(result);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><hr><h3 id="Thread类方法"><a href="#Thread类方法" class="headerlink" title="Thread类方法"></a>Thread类方法</h3><h5 id="currentThread-方法"><a href="#currentThread-方法" class="headerlink" title="currentThread()方法"></a>currentThread()方法</h5><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> Thread <span class="hljs-title">currentThread</span><span class="hljs-params">()</span></span>;</code></pre><p>currentThread()方法可返回代码段正在被哪个线程调用的信息。</p><h5 id="isAlive-方法"><a href="#isAlive-方法" class="headerlink" title="isAlive()方法"></a>isAlive()方法</h5><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAlive</span><span class="hljs-params">()</span></span>;</code></pre><p>方法isAlive()的功能是判断当前的线程是否处于活动(除开TERMINATED)状态。</p><h5 id="join-方法"><a href="#join-方法" class="headerlink" title="join()方法"></a>join()方法</h5><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-keyword">long</span> millis)</span></span>;</code></pre><p>调用线程对象的join()方法后,当前线程从RUNNABLE切换到WAITING/TIMED_WAITING状态，直到线程对象的run执行完毕。</p><h5 id="sleep-方法"><a href="#sleep-方法" class="headerlink" title="sleep()方法"></a>sleep()方法</h5><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-keyword">long</span> millis)</span></span>;</code></pre><p>sleep()方法会释放cpu的时间片，但是不会释放锁，调用sleep()之后从RUNNABLE状态转为TIMED_WAITING状态</p><h5 id="yield-方法"><a href="#yield-方法" class="headerlink" title="yield()方法"></a>yield()方法</h5><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">yield</span><span class="hljs-params">()</span></span>;</code></pre><p>提示线程调度器当前线程愿意放弃当前CPU的使用。如果当前资源不紧张，调度器可以忽略这个提示。本质上线程状态一直是RUNNABLE,但是我可以理解为RUNNABLE到RUNNING的转换</p><hr><h3 id="线程优先级和守护线程"><a href="#线程优先级和守护线程" class="headerlink" title="线程优先级和守护线程"></a>线程优先级和守护线程</h3><h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><p>java中的线程优先级的范围是1～10，默认的优先级是5。每个线程默认的优先级都与创建它的父线程具有相同的优先级。默认情况下，mian线程具有普通优先级。“高优先级线程”会优先于“低优先级线程”执行。”高优先级线程”可能会优先于“低优先级线程”执行，Thread提供了<code>setPriority()</code>和<code>getPriority()</code>方法来设置和返回线程优先级。</p><p> Thread类有3个静态常量： </p><pre><code class="hljs ini"><span class="hljs-attr">MAX_PRIORITY</span> = <span class="hljs-number">10</span><span class="hljs-attr">MIN_PRIORITY</span> = <span class="hljs-number">1</span><span class="hljs-attr">NORM_PRIORITY</span> = <span class="hljs-number">5</span></code></pre><hr><h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><ul><li><p>java 中有两种线程：用户线程和守护线程。可以通过<code>isDaemon()</code>方法来区别它们：如果返回false，则说明该线程是“用户线程”；否则就是“守护线程”。用户线程一般用户执行用户级任务，而守护线程也就是“后台线程”，一般用来执行后台任务，垃圾回收线程，就是最典型的守护线程。</p></li><li><p>所有的用户线程结束后，守护线程才会随之结束。</p></li><li><p>main线程是用户线程，main线程结束后，不会影响到其他用户线程。</p></li><li><p><code>setDaemon(true)</code>必须在调用线程的start()方法之前设置，否则会抛IllegalThreadStateException异常。</p></li><li><p>在守护线程中产生的新线程也是守护线程。 </p></li></ul><hr><h3 id="线程同步与线程安全"><a href="#线程同步与线程安全" class="headerlink" title="线程同步与线程安全"></a>线程同步与线程安全</h3><h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>CPU可能随机的在多个处于就绪状态中的线程中进行切换，就意味者一个线程并不是被执行完所有的语句之后才被切换的，所以多线程环境下对共享资源的访问可能会引起此共享资源的不一致性，这就是线程安全问题。为避免线程安全问题，应该避免多线程环境下对共享资源的并发访问。</p><hr><h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><p>java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（如数据的增删改查），将会导致数据不准确，相互之间产生冲突，因此加入同步机制以避免在该线程没有完成操作之前，被其他线程的调用，从而保证了该变量的唯一性和准确性。</p><h5 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h5><p>对共享资源进行访问的方法定义中加上synchronized关键字修饰，使得此方法称为同步方法。可以简单理解成对此方法进行了加锁，其锁对象为当前方法所在的对象自身。多线程环境下，当执行此方法时，首先都要获得此同步锁（且同时最多只有一个线程能够获得），只有当线程执行完此同步方法后，才会释放锁对象，其他的线程才有可能获取此同步锁，以此类推…。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;         <span class="hljs-comment">// ....</span>&#125;</code></pre><h5 id="同步块"><a href="#同步块" class="headerlink" title="同步块"></a>同步块</h5><p>解决线程安全问题其实只需限制对共享资源访问的不确定性即可。使用同步方法时，使得整个方法体都成为了同步执行状态，会使得可能出现同步范围过大的情况，于是，针对需要同步的代码可以直接另一种同步方式——同步代码块来解决。</p><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (obj) &#123;     <span class="hljs-comment">//...</span>&#125;</code></pre><p>其中，obj为锁对象，因此，选择哪一个对象作为锁是至关重要的。一般情况下，都是选择此共享资源对象作为锁对象。</p><h5 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h5><p><strong>原理：</strong><br>在java中，每一个对象有且仅有一个同步锁。这也意味着，同步锁是依赖于对象而存在。当前线程调用某对象的synchronized方法时，就获取了该对象的同步锁。例如，synchronized(obj)，当前线程就获取了“obj这个对象”的同步锁。不同线程对同步锁的访问是互斥的。也就是说，某时间点，对象的同步锁只能被一个线程获取到。</p><hr><h4 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h4><p><strong>wait() / notify() / notifyAll()</strong> ：都是Object类的方法。</p><ul><li><p>wait()：导致当前线程等待并使其进入到等待阻塞状态。直到其他线程调用该同步锁对象的notify()或notifyAll()方法来唤醒此线程。</p></li><li><p>notify()：唤醒在此同步锁对象上等待的单个线程，如果有多个线程都在此同步锁对象上等待，则会任意选择其中某个线程进行唤醒操作，只有当前线程放弃对同步锁对象的锁定，才可能执行被唤醒的线程。</p></li><li><p>notifyAll()：唤醒在此同步锁对象上等待的所有线程，只有当前线程放弃对同步锁对象的锁定，才可能执行被唤醒的线程。</p></li></ul><p>1.<code>wait()</code>方法执行后，当前线程立即进入到等待阻塞状态，其后面的代码不会执行； </p><p>2.<code>notify()</code>/<code>notifyAll()</code>方法执行后，将唤醒此同步锁对象上的（任意一个-<code>notify()</code>/所有-<code>notifyAll()</code>）线程对象，但是，此时还并没有释放同步锁对象，也就是说，如果<code>notify()</code>/<code>notifyAll()</code>后面还有代码，还会继续执行，直到当前线程执行完毕才会释放同步锁对象；</p><p>3.<code>notify()</code>/<code>notifyAll()</code>执行后，如果下面有<code>sleep()</code>方法，则会使当前线程进入到阻塞状态，但是同步对象锁没有释放，依然自己保留，那么一定时候后还是会继续执行此线程，接下来同2；</p><p>4.<code>wait()</code>/<code>notify()</code>/<code>nitifyAll()</code>完成线程间的通信或协作都是基于相同对象锁的，因此，如果是不同的同步对象锁将失去意义，同时，同步对象锁最好是与共享资源对象保持一一对应关系；</p><p>5.当wait线程唤醒后并执行时，是接着上次执行到的<code>wait()</code>方法代码后面继续往下执行的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初学Java-网络编程</title>
    <link href="/2019/12/16/%E5%88%9D%E5%AD%A6Java-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2019/12/16/%E5%88%9D%E5%AD%A6Java-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>网络编程总结</p><a id="more"></a><h3 id="TCP-与-UDP-协议"><a href="#TCP-与-UDP-协议" class="headerlink" title="TCP 与 UDP 协议"></a>TCP 与 UDP 协议</h3><ul><li>TCP：<br>提供面向连接的服务，在传输数据之前必须先建立连接，数据传输之后要释放连接。流模式。</li><li>UDP：<br>在传输数据之前不建立连接，直接发送数据报到网络。数据报模式。<h3 id="套字节与端口"><a href="#套字节与端口" class="headerlink" title="套字节与端口"></a>套字节与端口</h3></li><li>套接字：<br>当两台计算机连接起来建立一个双向的通信链路时，这个双向通信链路的每一端称之为一个套接字（Socket）。</li><li>端口:<br>一台服务器上可能提供多种服务，使用 IP 地址只能唯一定位到某一台计算机，却不能准确地连接到想要连接的服务器。通常使用一个 0~65535 的整数来标识该机器上的某个服务，这个整数就是端口号（Port）。<h3 id="Java-InetAddress-类"><a href="#Java-InetAddress-类" class="headerlink" title="Java InetAddress 类"></a>Java InetAddress 类</h3>Internet 上的主机有两种方式表示地址，分别为域名和 IP 地址。java.net 包中的 InetAddress 类对象包含一个主机地址的域名和 IP 地址。 </li></ul><p><strong>InetAddress类的常用方法 ：</strong></p><ul><li>static InetAddress[] getAHByName(String host)<br>在给定主机名的情况下，根据系统上配置的名称，服务器返回其 IP 地址所组成的数组</li><li>static InetAddress getByAddress(String host)<br>在给定主机名的情况下确定主机的 IP 地址</li><li>String getHostAddress()<br>返回 IP 地址字符串（以文本表现形式）</li><li>String getHostName()<br>返回此 IP 地址的主机名</li><li>static InetAdderss getLocalHost()<br>返回本地主机</li></ul><h3 id="Java-TCP通信"><a href="#Java-TCP通信" class="headerlink" title="Java TCP通信"></a>Java TCP通信</h3><p>TCP 网络程序是指利用 Socket 编写的通信程序。利用 TCP 协议进行通信的两个应用程序是有主次之分的，一个是服务器程序，一个是客户端程序，两者的功能和编写方法不太一样。其中 ServerSocket 类表示 Socket 服务器端，Socket 类表示 Socket 客户端。Socket 类表示 Socket 客户端，两者之间的交互过程如下：</p><ol><li>服务器端创建一个 ServerSocket （服务器端套接字），调用 accept() 方法等待客户端来连接。</li><li>客户端程序创建一个 Socket，请求与服务器建立连接。</li><li>服务器接收客户端的连接请求，同时创建一个新的 Socket 与客户端建立连接，服务器继续等待新的请求。</li></ol><h4 id="ServerSocket-类"><a href="#ServerSocket-类" class="headerlink" title="ServerSocket 类"></a>ServerSocket 类</h4><p>ServerSocket 类是与 Socket 类相对应的用于表示通信双方中的服务器端，用于在服务器上开一个端口，被动的等待数据（使用accept() 方法）并建立连接进行数据交互。<br>服务器套接字一次可与一个套接字连接，如果多台客户端同时提出连接请求，服务器套接字会将请求连接的客户端存入队列中，然后从中取出一个套接字与服务器新建的套接字连接起来，若请求连接大于最大容纳数，则多出的连接请求被拒绝；默认的队列大小是50。</p><p><strong>ServerSocket 类常用方法：</strong></p><ul><li>Server accept()：监听要连接到此套接字并接受它。 </li><li>void close()：关闭此套接字。</li></ul><p>调用 accept() 方法会返回一个和客户端 Socket 对象相连接的 Socket 对象</p><p>** 使用 ServerSocket 类创建一个使用端口 8888 的服务器端套接字，如下：**</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">//在8888端口创建一个服务器端套接字</span>        ServerSocket s_socket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8888</span>);        System.out.println(<span class="hljs-string">"服务器端 Socket 套接字创建成功！"</span>);        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;             System.out.println(<span class="hljs-string">"等待客户端的连接请求!"</span>);            <span class="hljs-comment">//等待客户端的连接请求</span>            Socket socket = s_socket.accept();             <span class="hljs-comment">//阻塞式创建连接</span>            <span class="hljs-comment">//如果没有客户端的连接请求，则 accept() 方法为空，</span>            <span class="hljs-comment">//所以不会输出“成功建立与客户端的连接”</span>            System.out.println(<span class="hljs-string">"成功建立与客户端的连接!"</span>);                        <span class="hljs-comment">//从客户端接收数据</span>            <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];        in = socket.getInputStream();        <span class="hljs-keyword">int</span> len = in.read(b);                        <span class="hljs-comment">//将数据发送到客户端</span>            out = socket.getOutputStream();<span class="hljs-comment">//发送数据</span>            out.write(<span class="hljs-string">"欢迎登陆到客户端！"</span>.getBytes());                    &#125;    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre><h4 id="Socket-类"><a href="#Socket-类" class="headerlink" title="Socket 类"></a>Socket 类</h4><p>Socket 类表示通信双方中的客户端，用于呼叫远端机器上的一个端口，主动向服务器端发送数据（当连接建立后也能接收数据）</p><p><strong>Socket类构造方法</strong></p><ul><li>Socket(InetAddress address,int port)：<br>创建一个流套接字并将其连接到指定 IP 地址的指定端口。</li></ul><p><strong>Socket 类常用方法：</strong></p><ul><li>void close()：<br>关闭此套接字。</li><li>InputStream getInputStream()：<br>返回此套接字的输入流。</li><li>OutputStream getOutputStream()：<br>返回此套接字的输出流。</li></ul><p><strong>使用Socket类创建客户端套接字，和服务器端完成简单的通信：</strong></p><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//1.定义 Socket 对象、OutputStream 对象和一个 InputStream 对象并完成初始化</span>        Socket socket = <span class="hljs-keyword">null</span>;        OutputStream out = <span class="hljs-keyword">null</span>;        InputStream in = <span class="hljs-keyword">null</span>;        <span class="hljs-comment">//定义服务器端的 IP 地址和端口号</span>        String serverIP = <span class="hljs-string">"127.0.0.1"</span>;<span class="hljs-comment">//服务器端 IP 地址</span>        <span class="hljs-keyword">int</span> port = <span class="hljs-number">8888</span>;<span class="hljs-comment">//服务器端端口号</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//2.建立与服务器端的连接并将数据发送到服务器端</span>            socket = <span class="hljs-keyword">new</span> Socket(serverIP, port);<span class="hljs-comment">//建立连接</span>            out = socket.getOutputStream();<span class="hljs-comment">//发送数据</span>            out.write(<span class="hljs-string">"我是客户端数据"</span>.getBytes());             <span class="hljs-comment">//3.从输入流中读出服务器的反馈信息并输出到控制台</span>            <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];            in = socket.getInputStream();            <span class="hljs-keyword">int</span> len = in.read(b);            System.out.println(<span class="hljs-string">"服务器端的反馈为："</span> + <span class="hljs-keyword">new</span> String(b, <span class="hljs-number">0</span>, len));        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">//4.关闭流及 Socket 对象</span>            <span class="hljs-keyword">try</span> &#123;                in.close();                out.close();                socket.close();            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</code></pre><h3 id="Java-UDP通信"><a href="#Java-UDP通信" class="headerlink" title="Java UDP通信"></a>Java UDP通信</h3><p>虽然 UDP 协议是一种不太可靠的协议，但有时在需要较快地接收数据并且可以忍受较小错误的情况下，UDP就会表现出更大的优势。</p><p><strong>使用 UDP 协议发送数据的步骤：</strong></p><ul><li>使用 DatagramSocket() 创建一个数据包套接字。</li><li>使用 DatagramPacket() 创建要发送的数据包。</li><li>使用 DatagramSocket 类的 send() 方法发送数据包。</li></ul><p><strong>接收 UDP 数据包的步骤：</strong></p><ul><li>使用 DatagramSocket 创建数据包套接字，并将其绑定到指定的端口。</li><li>使用 DatagramPacket 创建字节数组来接收数据包。</li><li>使用 DatagramPacket 类的 receive() 方法接收 UDP 包</li></ul><h4 id="DatagramPacket类"><a href="#DatagramPacket类" class="headerlink" title="DatagramPacket类"></a>DatagramPacket类</h4><p>DatagramPacket 类用来表示数据报包，数据报包用来实现无连接包投递服务。每条报文仅根据该包中包含的信息从一台机器路由到另一台机器。从一台机器发送到另一台机器的多个包可能选择不同的路由，也可能按不同的顺序到达。</p><h4 id="DatagramSocket-类"><a href="#DatagramSocket-类" class="headerlink" title="DatagramSocket 类"></a>DatagramSocket 类</h4><p>DatagramSocket 类用于表示发送和接收数据报包的套接字。数据报包套接字是包投递服务的发送或接收点。每个在数据报包套接字上发送或接收的包都是单独编址和路由的。</p><p><strong>UDP通信客户端/服务端：</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<span class="hljs-comment">//1.使用DatagramSocket 指定端口 创建接收端/服务端  端口号不能相同</span>DatagramSocket socket = <span class="hljs-keyword">new</span> DatagramSocket(<span class="hljs-number">8888</span>); <span class="hljs-comment">//  2.准备数据，接收方的地址(ip,端口)</span>    SocketAddress address = <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">"localhost"</span>,<span class="hljs-number">9999</span>);    <span class="hljs-keyword">byte</span>[] datas = <span class="hljs-string">"发送数据****"</span>.getBytes();<span class="hljs-comment">//3.封装成DatagramPacekt包裹，需要指定目的地 </span>DatagramPacket packet = <span class="hljs-keyword">new</span> DatagramPacket(datas,<span class="hljs-number">0</span>,datas.length,address);     <span class="hljs-comment">//  4.发送数据包</span>    socket.send(packet);        <span class="hljs-comment">//  5.准备空间接收数据包(数据包最大60K)</span>    <span class="hljs-keyword">byte</span>[] container = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">60</span>];    <span class="hljs-comment">//  6.构造 DatagramPacket，用来接收长度为 length 的数据包</span>DatagramPacket packet = <span class="hljs-keyword">new</span> DatagramPacket(container,container.length);<span class="hljs-comment">// * 5.阻塞式接收包裹receive(DatagramPacekt)</span>server.receive(packet);        <span class="hljs-comment">//关闭 DatagramSocket 对象</span>    server.colse();&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初学java-IO</title>
    <link href="/2019/12/13/%E5%88%9D%E5%AD%A6java-IO/"/>
    <url>/2019/12/13/%E5%88%9D%E5%AD%A6java-IO/</url>
    
    <content type="html"><![CDATA[<p>特地对java的IO做一个总结</p><a id="more"></a><h2 id="IO概述"><a href="#IO概述" class="headerlink" title="IO概述"></a>IO概述</h2><ul><li>IO中最重要的5个类和1个接口：<strong>File、OutputStream、InputStream、Writer、Reader；Serializable.</strong></li></ul><h2 id="io体系"><a href="#io体系" class="headerlink" title="io体系"></a>io体系</h2><p>从操作方向(<strong>代码的角度</strong>)来看，IO类可以分为：</p><ul><li>输入流：读取/输入数据 到代码</li><li>输出流：把代码的数据 写出/输出</li></ul><hr><p>从操作类型来看，IO类可以分为：</p><ul><li>字节流 : 字节流可以操作任何数据(文本，图片，视频)，因为所有的数据都是以字节的形式存储。</li><li>字符流 : 字符流只能操作字符数据。</li></ul><p><em>Q: 字符在计算机中是怎么表示的？</em><br><em>A：将字符是按照规则翻译对应的二进制数(编码)，一个字符通常用多个字节存储。</em></p><p><em>Q: 字节流可以操作字符数据吗？</em><br><em>A：”字节流可以操作任何数据 “，是可以操作的，但是。。。</em></p><p><em>Q: 字节流可以操作任何数据，为什么还需要字符流？</em><br><em>A：字节流处理文本文件会出现乱码问题(字节流不编码&amp;解码)，所以需要字符流来处理文本文件。</em></p><p><em>Q：那我就是想用字节流处理文本文件，咋办呢？</em><br><em>A：你自己用代码去编码，解码就可以了。</em></p><p><em>Q：那既然有字符流，为啥没有图片流，音频流，视频流？</em><br><em>A：emmm,我等下去问问老师。</em></p><p><em>Q：那什么时候用字符流，什么时候用字节流啊？</em><br><em>A：处理文本文件用字符流，其他的用字节流。</em></p><hr><p>从操作对象来看，IO类可以分为：</p><ul><li><p>文件(节点流)：对文件进行读取、写入操作。</p><pre><code class="hljs java">FileInputStream, FileOutputStreamFileWriter, FileReader</code></pre></li><li><p>数组(节点流)：对数组进行读取、写入操作。</p><pre><code class="hljs java">ByteArrayInputStream, ByteArrayOutputStreamCharArrayReader, CharArrayWriter</code></pre></li><li><p>管道操作(节点流)：实现管道的输入和输出（线程间通信）。</p><pre><code class="hljs java">PipedInputStream, PipedOutputStreamPipedReader, PipedWriter</code></pre></li><li><p>缓冲操作(处理流)：在读入或写出时，对数据进行缓存，以减少I/O的次数。</p><pre><code class="hljs java">BufferedInputStream, BufferedOutputStreamBufferedReader, BufferedWriter</code></pre></li><li><p>字节转换字符(处理流)：按照一定的编码/解码标准将字节流转换为字符流。</p><pre><code class="hljs java">InputStreamReader、OutputStreWriter</code></pre></li><li><p>打印(处理流)：包含方便的打印方法 。</p><pre><code class="hljs java">PrintStream、PrintWriter</code></pre></li><li><p>基本数据类型(处理流)：允许应用程序以与机器无关方式从底层输入流中读写基本 Java 数据类型。</p><pre><code class="hljs java">DataInputStream、DataOutputStream</code></pre></li><li><p>对象序列化反序列化(处理流)：保存在内存中的各种对象的状态。</p><pre><code class="hljs java">ObjectInputStream、ObjectOutputStream</code></pre></li></ul><p><strong>节点流：程序用于直接操作目标设备所对应的类</strong><br><strong>处理流：程序通过一个间接流类去调用节点流类，以达到更加灵活方便地读写各种类型的数据</strong><br><strong>节点流是一杯原味咖啡的话，处理流就是各种配料，让节点流更好喝</strong></p><p><em>Q：处理流要怎么使用呢？</em><br><em>A：实例化处理流类的时候要给一个节点流对象，</em></p><pre><code class="hljs java">BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader());InputStreamReader isr = <span class="hljs-keyword">new</span> InputStreamReader(<span class="hljs-keyword">new</span> FileInputStream());</code></pre><p><em>Q：为什么不直接操作数组，而用内存数组流呢？</em><br><em>A：数组是基本数据类型，而内存数组流是类，就和有<code>int</code>但是还有Integer类是一样的。</em></p><p><em>Q：管道是啥啊？</em><br><em>A：emmm,我也不懂，等我学会了再告诉你……</em></p><p><em>Q：什么情况下用缓存流啊？</em><br><em>A：缓存流可以优化性能，看到文件流和数组流就套上去。但是没必要套几个缓存流，一个就够了。</em></p><pre><code class="hljs java">BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader());</code></pre><p><em>Q：什么情况下用字节转换字符流啊？</em><br><em>A：<code>FileReader</code>和 <code>FileWriter</code>的<strong>字符编码</strong>是IDEA的设置，要使用别的<strong>字符编码</strong>，就用字节转换字节流。</em></p><pre><code class="hljs java">InputStreamReader isr = <span class="hljs-keyword">new</span> InputStreamReader(<span class="hljs-keyword">new</span> FileInputStream(),<span class="hljs-string">"GBK"</span>);</code></pre><p><em>Q：打印流可以用来辅助输入流吗？</em><br><em>A：不可以，打印流只能为其他输出流添加功能。所以打印流永远不会抛出IO异常。</em></p><p><em>Q：<code>PrintStream</code>和 <code>PrintWriter</code>有么区别啊？</em><br><em>A：<code>PrintStream</code>和 <code>PrintWriter</code>中的方法是一样的，但是 <code>PrintWriter</code>的构造方法比 <code>PrintStream</code>多了一个接收 字符流 的构成方法( <code>PrintWriter</code>比 <code>PrintStream</code>灵活)，所以掌握 <code>PrintWriter</code>就可以了</em></p><p><em>Q：基本数据类型流是的功能好像不是很有用唉！</em><br><em>A：有用的很！用 <code>FileOutputStream</code>写入一个<code>int</code>类型的数据到文件，只会写入最低位，。而用 <code>DataOutputStream</code>就能避免这样的情况。</em></p><p><em>Q：那使用基本数据类型流有什么要注意的？</em><br><em>A：读取数据的顺序一定要和写入的顺序一致。</em></p><p><em>Q：所以的对象都可以通过序列化保持下来吗？</em><br><em>A：只要该类实现了 <code>java.io.Serializable</code>接口，都可以序列化或者反序列化。如果有属性不需要序列化，可以用 <code>transient</code>关键字修饰。</em></p><hr>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>IO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown命令</title>
    <link href="/2019/11/17/%E5%B8%B8%E7%94%A8Markd%E5%91%BD%E4%BB%A4/"/>
    <url>/2019/11/17/%E5%B8%B8%E7%94%A8Markd%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>记录一些常用的Markdown语法。</p><a id="more"></a><h2 id="mermaid"><a href="#mermaid" class="headerlink" title="mermaid"></a>mermaid</h2><p>语法框架：</p><pre><code class="hljs apl">```mermaid    ……流程图代码……```</code></pre><hr><p>起始代码：<br>graph &lt;布局方向&gt;</p><pre><code class="hljs apl">graph TB    ...    ...</code></pre><p>TB（Top Bottom）表示从上向下布局<br>BT（Bottom Top）表示从下向下布局<br>LR（Left Right）表示从左向右布局<br>RL（Right Left）表示从右向左布局</p>]]></content>
    
    
    
    <tags>
      
      <tag>常用命令</tag>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo命令</title>
    <link href="/2019/11/17/Hexo%E5%91%BD%E4%BB%A4/"/>
    <url>/2019/11/17/Hexo%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>记录一些常用的Hexo命令。</p><a id="more"></a><h3 id="hexo-s"><a href="#hexo-s" class="headerlink" title="hexo s"></a>hexo s</h3><p><code>hexo s</code></p><ul><li>启动本地服务器，用于预览主题。默认地址： <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></li><li>hexo s 是 hexo server 的缩写，命令效果一致；</li><li>预览的同时可以修改文章内容或主题代码，保存后刷新页面即可；</li><li>对 Hexo 根目录 _config.yml 的修改，需要重启本地服务器后才能预览效果。</li></ul><hr><h3 id="hexo-new"><a href="#hexo-new" class="headerlink" title="hexo new"></a>hexo new</h3><p><code>hexo new &quot;常用hexo语法 一&quot;</code></p><ul><li>新建一篇标题为 常用hexo命令 一 的文章，因为标题里有空格，所以加上了引号。</li><li>文章标题可以在对应 md 文件里改，新建时标题可以写的简单些。</li></ul><hr><h3 id="hexo-d"><a href="#hexo-d" class="headerlink" title="hexo d"></a>hexo d</h3><p><code>hexo d</code></p><ul><li><p>自动生成网站静态文件，并部署到设定的仓库。</p></li><li><p>hexo d 是 hexo deploy 的缩写，命令效果一致。</p></li></ul><hr><h3 id="hexo-clean"><a href="#hexo-clean" class="headerlink" title="hexo clean"></a>hexo clean</h3><p><code>hexo clean</code></p><ul><li>清除缓存文件 db.json 和已生成的静态文件 public 。</li><li>网站显示异常时可以执行这条命令试试。</li></ul><hr><h3 id="hexo-g"><a href="#hexo-g" class="headerlink" title="hexo g"></a>hexo g</h3><p><code>hexo g</code></p><ul><li>生成网站静态文件到默认设置的 public 文件夹。</li><li>便于查看网站生成的静态文件或者手动部署网站；</li><li>如果使用自动部署，不需要先执行该命令；</li><li>hexo g 是 hexo generate 的缩写，命令效果一致。</li></ul><hr><h3 id="hexo-new-page"><a href="#hexo-new-page" class="headerlink" title="hexo new page"></a>hexo new page</h3><p><code>hexo new page aboutme</code></p><ul><li>新建一个标题为 aboutme 的页面，默认链接地址为 主页地址/aboutme/</li><li>标题可以为中文，但一般习惯用英文；</li><li>页面标题和文章一样可以随意修改；</li><li>页面不会出现在首页文章列表和归档中，也不支持设置分类和标签。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>常用命令</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
