<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>源码解读-LinkedList</title>
      <link href="/2020/10/05/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-LinkedList/"/>
      <url>/2020/10/05/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-LinkedList/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>LinkedList是 java 集合框架中比较常用的数据结构，是List最重要的两个实现类，底层是链表，适合数据更新多的情况。</p><h1 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h1><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span>&lt;<span class="hljs-title">E</span>&gt;    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSequentialList</span>&lt;<span class="hljs-title">E</span>&gt;    <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Deque</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span></code></pre><p>LinkedList不仅实现了List，还实现了Deque（双端队列）</p><h1 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h1><pre><code class="hljs java"><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>; <span class="hljs-comment">//链表中的数量</span><span class="hljs-comment">/** * Pointer to first node. * Invariant: (first == null &amp;&amp; last == null) || *            (first.prev == null &amp;&amp; first.item != null) */</span><span class="hljs-keyword">transient</span> Node&lt;E&gt; first; <span class="hljs-comment">//头节点</span><span class="hljs-comment">/** * Pointer to last node. * Invariant: (first == null &amp;&amp; last == null) || *            (last.next == null &amp;&amp; last.item != null) */</span><span class="hljs-keyword">transient</span> Node&lt;E&gt; last;  <span class="hljs-comment">//尾节点</span></code></pre><p>字段非常少，size表示当前节点数量，first指向链表的起始元素、last指向链表的最后一个元素。</p><p>我们来看一下 <code>Node</code>: </p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;    E item;        <span class="hljs-comment">//元素</span>    Node&lt;E&gt; next;  <span class="hljs-comment">//后继</span>    Node&lt;E&gt; prev;  <span class="hljs-comment">//前驱</span>    <span class="hljs-comment">//构造方法，指定前驱和后继</span>    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;        <span class="hljs-keyword">this</span>.item = element;        <span class="hljs-keyword">this</span>.next = next;        <span class="hljs-keyword">this</span>.prev = prev;    &#125;&#125;</code></pre><p>Node 节点有前驱和后继，所有LinkedList的底层是一个双向链表</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><h3 id="无参构造方法"><a href="#无参构造方法" class="headerlink" title="无参构造方法"></a>无参构造方法</h3><p>构造一个空链表</p><pre><code class="hljs java"><span class="hljs-comment">/** * Constructs an empty list.*/</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedList</span><span class="hljs-params">()</span> </span>&#123;&#125;</code></pre><h3 id="有参构造方法"><a href="#有参构造方法" class="headerlink" title="有参构造方法"></a>有参构造方法</h3><p> 将指定Collection对象里的元素构造成一个LinkedList</p><pre><code class="hljs java"><span class="hljs-comment">/** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection's * iterator. * * <span class="hljs-doctag">@param</span>  c the collection whose elements are to be placed into this list * <span class="hljs-doctag">@throws</span> NullPointerException if the specified collection is null */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;    <span class="hljs-keyword">this</span>();    addAll(c);&#125;</code></pre><h1 id="链表相关操作"><a href="#链表相关操作" class="headerlink" title="链表相关操作"></a>链表相关操作</h1><p>因为LinkedList的底层是链表，所以我们来看一下相关方法。</p><h2 id="linkLast-E-e"><a href="#linkLast-E-e" class="headerlink" title="linkLast(E e)"></a>linkLast(E e)</h2><p>将元素链接到表尾</p><pre><code class="hljs java"><span class="hljs-comment">/** * Links e as last element. */</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">linkLast</span><span class="hljs-params">(E e)</span> </span>&#123;    <span class="hljs-comment">//last指向表尾</span>    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;         <span class="hljs-comment">//创建一个node，前驱是last，后继为null</span>    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> Node&lt;&gt;(l, e, <span class="hljs-keyword">null</span>);        <span class="hljs-comment">//开始链接    </span>    <span class="hljs-comment">//更新last，last指向表尾</span>    last = newNode;        <span class="hljs-keyword">if</span> (l == <span class="hljs-keyword">null</span>)        first = newNode;   <span class="hljs-comment">//如果链表只有一个节点，那么双向链表的first和last指向同一个节点</span>    <span class="hljs-keyword">else</span>        l.next = newNode;  <span class="hljs-comment">//将newNode链接到最后一个元素。</span>    <span class="hljs-comment">//更新size</span>    size++;    modCount++;&#125;</code></pre><p>图示如下：</p><p><img src="http://smartrobin.cn/linkLast.png" srcset="/img/loading.gif" alt=""></p><h2 id="linkFirst-E-e"><a href="#linkFirst-E-e" class="headerlink" title="linkFirst(E e)"></a>linkFirst(E e)</h2><p>链接元素到表头</p><pre><code class="hljs java"><span class="hljs-comment">/** * Links e as first element. */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">linkFirst</span><span class="hljs-params">(E e)</span> </span>&#123;    <span class="hljs-comment">// first指向表头</span>    <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;    <span class="hljs-comment">// 创建一个newNode，前驱为null，后继为first</span>    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> Node&lt;&gt;(<span class="hljs-keyword">null</span>, e, f);       <span class="hljs-comment">// 开始链接操作</span>    <span class="hljs-comment">// 更新first, first指向表头</span>    first = newNode;    <span class="hljs-keyword">if</span> (f == <span class="hljs-keyword">null</span>)        last = newNode;  <span class="hljs-comment">//如果链表只有一个节点，那么双向链表的first和last指向同一个节点</span>    <span class="hljs-keyword">else</span>        f.prev = newNode;  <span class="hljs-comment">//将newNode链接到表头。</span>    <span class="hljs-comment">//更新size</span>    size++;    modCount++;&#125;</code></pre><p>图示如下</p><p><img src="http://smartrobin.cn/linkFirst.png" srcset="/img/loading.gif" alt=""></p><h2 id="linkBefore-E-e-Node-succ"><a href="#linkBefore-E-e-Node-succ" class="headerlink" title="linkBefore(E e, Node succ)"></a>linkBefore(E e, Node<E> succ)</h2><p>将元素链接在node之前</p><pre><code class="hljs java"><span class="hljs-comment">/** * Inserts element e before non-null Node succ. */</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">linkBefore</span><span class="hljs-params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;    <span class="hljs-comment">// assert succ != null;</span>        <span class="hljs-comment">// 找到前驱节点</span>    <span class="hljs-keyword">final</span> Node&lt;E&gt; pred = succ.prev;        <span class="hljs-comment">//创建一个newNode，前驱和succ的前驱，后继是succ</span>    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> Node&lt;&gt;(pred, e, succ);        <span class="hljs-comment">//更新succ的前驱为newNode</span>    succ.prev = newNode;        <span class="hljs-keyword">if</span> (pred == <span class="hljs-keyword">null</span>)        first = newNode;   <span class="hljs-comment">//如果succ是表头，则更新first为newNode</span>    <span class="hljs-keyword">else</span>        pred.next = newNode;  <span class="hljs-comment">//</span>    <span class="hljs-comment">//更新size</span>    size++;    modCount++;&#125;</code></pre><p>图示如下：</p><p><img src="http://smartrobin.cn/linkBefore.png" srcset="/img/loading.gif" alt=""></p><h2 id="unlinkFirst-Node-f"><a href="#unlinkFirst-Node-f" class="headerlink" title="unlinkFirst(Node f)"></a>unlinkFirst(Node<E> f)</h2><p>删除头节点f，并返回其元素。</p><pre><code class="hljs java"><span class="hljs-comment">/** * Unlinks non-null first node f. */</span><span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">unlinkFirst</span><span class="hljs-params">(Node&lt;E&gt; f)</span> </span>&#123;    <span class="hljs-comment">// assert f == first &amp;&amp; f != null;</span>    <span class="hljs-keyword">final</span> E element = f.item;    <span class="hljs-comment">// 节点f的后继</span>    <span class="hljs-keyword">final</span> Node&lt;E&gt; next = f.next;       f.item = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span>    f.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span>    <span class="hljs-comment">// 更新 first</span>    first = next;    <span class="hljs-keyword">if</span> (next == <span class="hljs-keyword">null</span>)        last = <span class="hljs-keyword">null</span>;   <span class="hljs-comment">//此时链表为空，last，first同时指向null</span>    <span class="hljs-keyword">else</span>        next.prev = <span class="hljs-keyword">null</span>; <span class="hljs-comment">//将next的前驱置为null</span>    <span class="hljs-comment">//更新size</span>    size--;    modCount++;    <span class="hljs-comment">//返回元素</span>    <span class="hljs-keyword">return</span> element;&#125;</code></pre><p>图示如下：</p><p><img src="http://smartrobin.cn/unLinkFirst.png" srcset="/img/loading.gif" alt=""></p><h2 id="unlinkLast-Node-l"><a href="#unlinkLast-Node-l" class="headerlink" title="unlinkLast(Node l)"></a>unlinkLast(Node<E> l)</h2><p>删除尾节点L，并返回其元素。</p><pre><code class="hljs java"><span class="hljs-comment">/** * Unlinks non-null last node l. */</span><span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">unlinkLast</span><span class="hljs-params">(Node&lt;E&gt; l)</span> </span>&#123;    <span class="hljs-comment">// assert l == last &amp;&amp; l != null;</span>    <span class="hljs-keyword">final</span> E element = l.item;    <span class="hljs-comment">//节点l的前驱</span>    <span class="hljs-keyword">final</span> Node&lt;E&gt; prev = l.prev;    l.item = <span class="hljs-keyword">null</span>;    l.prev = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span>    <span class="hljs-comment">//更新last</span>    last = prev;    <span class="hljs-keyword">if</span> (prev == <span class="hljs-keyword">null</span>)        first = <span class="hljs-keyword">null</span>;   <span class="hljs-comment">//此时链表为空，last，first同时指向null</span>    <span class="hljs-keyword">else</span>        prev.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">//将prev的后继置为null</span>    <span class="hljs-comment">//更新size</span>    size--;    modCount++;    <span class="hljs-keyword">return</span> element;&#125;</code></pre><p><img src="http://smartrobin.cn/unLinkLast.png" srcset="/img/loading.gif" alt=""></p><h2 id="unlink-Node-x"><a href="#unlink-Node-x" class="headerlink" title="unlink(Node x)"></a>unlink(Node<E> x)</h2><pre><code class="hljs java"><span class="hljs-comment">/** * Unlinks non-null node x. */</span><span class="hljs-function">E <span class="hljs-title">unlink</span><span class="hljs-params">(Node&lt;E&gt; x)</span> </span>&#123;    <span class="hljs-comment">// assert x != null;</span>    <span class="hljs-keyword">final</span> E element = x.item;    <span class="hljs-comment">// 后继</span>    <span class="hljs-keyword">final</span> Node&lt;E&gt; next = x.next;    <span class="hljs-comment">// 前驱</span>    <span class="hljs-keyword">final</span> Node&lt;E&gt; prev = x.prev;       <span class="hljs-keyword">if</span> (prev == <span class="hljs-keyword">null</span>) &#123;        first = next;  <span class="hljs-comment">//如果前驱是null，更新first</span>    &#125; <span class="hljs-keyword">else</span> &#123;        prev.next = next;  <span class="hljs-comment">//更新prev的后继</span>        x.prev = <span class="hljs-keyword">null</span>;       &#125;    <span class="hljs-keyword">if</span> (next == <span class="hljs-keyword">null</span>) &#123;  <span class="hljs-comment">//如果后继是null，更新last</span>        last = prev;    &#125; <span class="hljs-keyword">else</span> &#123;        next.prev = prev;  <span class="hljs-comment">//更新next的前驱</span>        x.next = <span class="hljs-keyword">null</span>;    &#125;    x.item = <span class="hljs-keyword">null</span>;    size--;    modCount++;    <span class="hljs-keyword">return</span> element;&#125;</code></pre><p>如图所示：</p><p><img src="http://smartrobin.cn/unLink.png" srcset="/img/loading.gif" alt=""></p><h2 id="node-int-index"><a href="#node-int-index" class="headerlink" title="node(int index)"></a>node(int index)</h2><p>找到index位置上的节点。</p><pre><code class="hljs java"><span class="hljs-comment">/** * Returns the (non-null) Node at the specified element index. */</span><span class="hljs-function">Node&lt;E&gt; <span class="hljs-title">node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;    <span class="hljs-comment">// assert isElementIndex(index);</span>    <span class="hljs-keyword">if</span> (index &lt; (size &gt;&gt; <span class="hljs-number">1</span>)) &#123;  <span class="hljs-comment">//从前找</span>        Node&lt;E&gt; x = first;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; index; i++)            x = x.next;        <span class="hljs-keyword">return</span> x;    &#125; <span class="hljs-keyword">else</span> &#123;        Node&lt;E&gt; x = last;     <span class="hljs-comment">//从后找</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = size - <span class="hljs-number">1</span>; i &gt; index; i--)            x = x.prev;        <span class="hljs-keyword">return</span> x;    &#125;&#125;</code></pre><h1 id="List相关操作"><a href="#List相关操作" class="headerlink" title="List相关操作"></a>List相关操作</h1><h2 id="add-E-e"><a href="#add-E-e" class="headerlink" title="add(E e)"></a>add(E e)</h2><p>追加一个指定元素到list尾部，调用了<code>LinkLast</code>方法。</p><pre><code class="hljs java"><span class="hljs-comment">/** * Appends the specified element to the end of this list. * * &lt;p&gt;This method is equivalent to &#123;<span class="hljs-doctag">@link</span> #addLast&#125;. * * <span class="hljs-doctag">@param</span> e element to be appended to this list * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> true&#125; (as specified by &#123;<span class="hljs-doctag">@link</span> Collection#add&#125;) */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;        linkLast(e);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre><h2 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h2><p>删除指定元素，底层调用 unlink方法</p><pre><code class="hljs java"><span class="hljs-comment">/** * Removes the first occurrence of the specified element from this list, * if it is present.  If this list does not contain the element, it is * unchanged.  More formally, removes the element with the lowest index * &#123;<span class="hljs-doctag">@code</span> i&#125; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt; * (if such an element exists).  Returns &#123;<span class="hljs-doctag">@code</span> true&#125; if this list * contained the specified element (or equivalently, if this list * changed as a result of the call). * * <span class="hljs-doctag">@param</span> o element to be removed from this list, if present * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> true&#125; if this list contained the specified element */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object o)</span> </span>&#123;      <span class="hljs-comment">//如果指定删除元素为null</span>    <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-keyword">null</span>; x = x.next) &#123;            <span class="hljs-keyword">if</span> (x.item == <span class="hljs-keyword">null</span>) &#123;                unlink(x);                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-keyword">null</span>; x = x.next) &#123;            <span class="hljs-keyword">if</span> (o.equals(x.item)) &#123;                unlink(x);                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre><p>大致流程是：先遍历找到指定元素，然后调用unlink方法删除。如果没找到，则返回false</p><h2 id="addAll-Collection-lt-extends-E-gt-c"><a href="#addAll-Collection-lt-extends-E-gt-c" class="headerlink" title="addAll(Collection&lt;? extends E&gt; c)"></a>addAll(Collection&lt;? extends E&gt; c)</h2><p>将Collection对象中的所有元素都添加到链表末尾</p><pre><code class="hljs java"><span class="hljs-comment">/** * Appends all of the elements in the specified collection to the end of * this list, in the order that they are returned by the specified * collection's iterator.  The behavior of this operation is undefined if * the specified collection is modified while the operation is in * progress.  (Note that this will occur if the specified collection is * this list, and it's nonempty.) * * <span class="hljs-doctag">@param</span> c collection containing elements to be added to this list * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> true&#125; if this list changed as a result of the call * <span class="hljs-doctag">@throws</span> NullPointerException if the specified collection is null */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;    <span class="hljs-keyword">return</span> addAll(size, c);&#125;</code></pre><h2 id="addAll-int-index-Collection-lt-extends-E-gt-c"><a href="#addAll-int-index-Collection-lt-extends-E-gt-c" class="headerlink" title="addAll(int index, Collection&lt;? extends E&gt; c)"></a>addAll(int index, Collection&lt;? extends E&gt; c)</h2><p>将Collection对象中的所有元素都插入到指定位置上，其实这个方法实现和linkBefore是差不多的，只不过是一次插入多个元素。</p><pre><code class="hljs java">** * Inserts all of the elements in the specified collection into <span class="hljs-keyword">this</span> * list, starting at the specified position.  Shifts the element * <span class="hljs-function">currently at that <span class="hljs-title">position</span> <span class="hljs-params">(<span class="hljs-keyword">if</span> any)</span> and any subsequent elements to * the <span class="hljs-title">right</span> <span class="hljs-params">(increases their indices)</span>.  The new elements will appear * in the list in the order that they are returned by the * specified collection's iterator. * * @param index index at which to insert the first element *              from the specified collection * @param c collection containing elements to be added to <span class="hljs-keyword">this</span> list */<span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addAll</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;    <span class="hljs-comment">//检查index是否合理</span>    checkPositionIndex(index);    Object[] a = c.toArray();    <span class="hljs-keyword">int</span> numNew = a.length;    <span class="hljs-keyword">if</span> (numNew == <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        Node&lt;E&gt; pred, succ;        <span class="hljs-comment">//找到pred，和succ</span>    <span class="hljs-keyword">if</span> (index == size) &#123; <span class="hljs-comment">//如果index和size相等，则在末尾添加。</span>        succ = <span class="hljs-keyword">null</span>;        pred = last;      &#125; <span class="hljs-keyword">else</span> &#123;        succ = node(index); <span class="hljs-comment">//找到index上的节点</span>        pred = succ.prev;       &#125;    <span class="hljs-comment">// 这里可以想象成是插入了一个节点</span>    <span class="hljs-keyword">for</span> (Object o : a) &#123;        <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>) E e = (E) o;        <span class="hljs-comment">//创建newNode</span>        Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> Node&lt;&gt;(pred, e, <span class="hljs-keyword">null</span>);        <span class="hljs-keyword">if</span> (pred == <span class="hljs-keyword">null</span>)            first = newNode; <span class="hljs-comment">// 如果前驱是null，则该newNode就是头结点</span>        <span class="hljs-keyword">else</span>            pred.next = newNode;  <span class="hljs-comment">//更新pred的后继</span>        <span class="hljs-comment">//更新pred</span>        pred = newNode;    &#125;    <span class="hljs-keyword">if</span> (succ == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">//如果succ是null，则更新last</span>        last = pred;      &#125; <span class="hljs-keyword">else</span> &#123;        pred.next = succ;  <span class="hljs-comment">//更新pred的后继</span>        succ.prev = pred;  <span class="hljs-comment">//更新suss的前驱</span>    &#125;    size += numNew;    modCount++;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre><h2 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h2><p>删除list中的所有元素。</p><pre><code class="hljs java"><span class="hljs-comment">/** * Removes all of the elements from this list. * The list will be empty after this call returns. */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// Clearing all of the links between nodes is "unnecessary", but:</span>    <span class="hljs-comment">// - helps a generational GC if the discarded nodes inhabit</span>    <span class="hljs-comment">//   more than one generation</span>    <span class="hljs-comment">// - is sure to free memory even if there is a reachable Iterator</span>    <span class="hljs-comment">//遍历删除</span>    <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-keyword">null</span>; ) &#123;        Node&lt;E&gt; next = x.next;                x.item = <span class="hljs-keyword">null</span>;   <span class="hljs-comment">//help GC</span>        x.next = <span class="hljs-keyword">null</span>;         x.prev = <span class="hljs-keyword">null</span>;        x = next;      &#125;        first = last = <span class="hljs-keyword">null</span>;    size = <span class="hljs-number">0</span>;    modCount++;&#125;</code></pre><h2 id="get-int-index"><a href="#get-int-index" class="headerlink" title="get(int index)"></a>get(int index)</h2><p>获取list中指定位置的元素。</p><pre><code class="hljs java"><span class="hljs-comment">/** * Returns the element at the specified position in this list. * * <span class="hljs-doctag">@param</span> index index of the element to return * <span class="hljs-doctag">@return</span> the element at the specified position in this list * <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125; */</span><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;    <span class="hljs-comment">//先检查index是否合理</span>    checkElementIndex(index);    <span class="hljs-comment">//返回元素</span>    <span class="hljs-keyword">return</span> node(index).item;&#125;</code></pre><h2 id="set-int-index，E-element"><a href="#set-int-index，E-element" class="headerlink" title="set(int index，E element)"></a>set(int index，E element)</h2><p>修改list中指定位置的元素</p><pre><code class="hljs java"><span class="hljs-comment">/** * Replaces the element at the specified position in this list with the * specified element. * * <span class="hljs-doctag">@param</span> index index of the element to replace * <span class="hljs-doctag">@param</span> element element to be stored at the specified position * <span class="hljs-doctag">@return</span> the element previously at the specified position * <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125; */</span><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;    <span class="hljs-comment">// 检查index是否合理</span>    checkElementIndex(index);    <span class="hljs-comment">// 找到节点</span>    Node&lt;E&gt; x = node(index);    <span class="hljs-comment">// 修改元素</span>    E oldVal = x.item;    x.item = element;<span class="hljs-comment">// 返回旧元素</span>    <span class="hljs-keyword">return</span> oldVal;&#125;</code></pre><h1 id="Deque相关操作"><a href="#Deque相关操作" class="headerlink" title="Deque相关操作"></a>Deque相关操作</h1><h2 id="getFirst"><a href="#getFirst" class="headerlink" title="getFirst()"></a>getFirst()</h2><p>返回队头元素，如果是空队列则抛出异常</p><pre><code class="hljs java"><span class="hljs-comment">/** * Returns the first element in this list. * * <span class="hljs-doctag">@return</span> the first element in this list * <span class="hljs-doctag">@throws</span> NoSuchElementException if this list is empty */</span><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;    <span class="hljs-keyword">if</span> (f == <span class="hljs-keyword">null</span>)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();    <span class="hljs-keyword">return</span> f.item;&#125;</code></pre><h2 id="getLast"><a href="#getLast" class="headerlink" title="getLast()"></a>getLast()</h2><p>返回队尾元素，如果是空队列则抛出异常</p><pre><code class="hljs java"><span class="hljs-comment">/** * Returns the last element in this list. * * <span class="hljs-doctag">@return</span> the last element in this listjava * <span class="hljs-doctag">@throws</span> NoSuchElementException if this list is empty */</span><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">getLast</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;    <span class="hljs-keyword">if</span> (l == <span class="hljs-keyword">null</span>)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();    <span class="hljs-keyword">return</span> l.item;&#125;</code></pre><h2 id="removeFirst"><a href="#removeFirst" class="headerlink" title="removeFirst()"></a>removeFirst()</h2><p>删除队头元素，如果是空队列则抛出异常。</p><pre><code class="hljs java"><span class="hljs-comment">/** * Removes and returns the first element from this list. * * <span class="hljs-doctag">@return</span> the first element from this list * <span class="hljs-doctag">@throws</span> NoSuchElementException if this list is empty */</span><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">removeFirst</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;    <span class="hljs-keyword">if</span> (f == <span class="hljs-keyword">null</span>)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();    <span class="hljs-comment">//调用的双向链表的移除头节点操作</span>    <span class="hljs-keyword">return</span> unlinkFirst(f);&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 源码解读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> LinkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-迭代器</title>
      <link href="/2020/10/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
      <url>/2020/10/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>迭代器模式 (Iterator Pattern) 又称为游标 (Cursor) 模式 ，其源于对容器的访问。容器对象的访问必然会设计遍历算法，我们可以将遍历的方法封装在容器中，或者不提供遍历方法。</p><p>如果我们将遍历的方法封装到容器中，那么对于容器类来说就承担了过多的功能，容器类不仅仅要维护自身内部的数据元素而且还要对外提供遍历的接口方法，因为遍历状态的存储问题还不能对同一个容器同时进行多个遍历操作。</p><p>如果我们不提供遍历方法而让使用者自己去实现，又会让容器内部细节暴露无遗。</p><p>正因于此，迭代模式应运而生，在客户访问类与容器体之间插入了一个第三者 - 迭代器，很好地解决了上面所述的弊端。</p>]]></content>
      
      
      <categories>
          
          <category> 初学Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>源码解读-AbstractList</title>
      <link href="/2020/10/04/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-AbstractList/"/>
      <url>/2020/10/04/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-AbstractList/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>AbstractList是实现List接口的抽象类，</p>]]></content>
      
      
      <categories>
          
          <category> 源码解读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> AbstractList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>源码解读-ArrayList</title>
      <link href="/2020/10/04/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-ArrayList/"/>
      <url>/2020/10/04/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-ArrayList/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>ArrayList 是 java 集合框架中比较常用的数据结构，是List最重要的两个实现类，底层是数组，适合数据查询多的情况。</p><h1 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h1><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractList</span>&lt;<span class="hljs-title">E</span>&gt;  <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">RandomAccess</span>, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">erializable</span></span></code></pre><p>AbstractList实现了通用的List方法，</p><p>ArrayList支持 随机访问，复制，序列化 所以实现了RandomAccess，Cloneable，erializable接口</p><h1 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h1><pre><code class="hljs java"><span class="hljs-comment">//版本号</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">8683452581122892189L</span>;<span class="hljs-comment">//默认容量</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CAPACITY = <span class="hljs-number">10</span>;<span class="hljs-comment">//空元素数组</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;<span class="hljs-comment">//默认空元素数组</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<span class="hljs-comment">//元素数组</span><span class="hljs-keyword">transient</span> Object[] elementData; <span class="hljs-comment">//实际元素大小</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<span class="hljs-comment">//最大数组容量</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="hljs-number">8</span>;</code></pre><p>ArrayList的底层实现是数组，数组必定是有限长度的，ArrayList中默认的数组大小是10。</p><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><h2 id="无参构造方法"><a href="#无参构造方法" class="headerlink" title="无参构造方法"></a>无参构造方法</h2><pre><code class="hljs java"><span class="hljs-comment">/** * Constructs an empty list with an initial capacity of ten. * 构造有十个初始容量的空列表 */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;</code></pre><p>虽然注释说 这个空列表的初始容量是十个，其实是懒加载的，只有在第一次调用<code>add()</code>方法后才会有初始化。</p><h2 id="有参构造方法（一）"><a href="#有参构造方法（一）" class="headerlink" title="有参构造方法（一）"></a>有参构造方法（一）</h2><pre><code class="hljs java"><span class="hljs-comment">/** * Constructs an empty list with the specified initial capacity. * * <span class="hljs-doctag">@param</span>  initialCapacity  the initial capacity of the list * <span class="hljs-doctag">@throws</span> IllegalArgumentException if the specified initial capacity *         is negative */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;    <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">this</span>.elementData = <span class="hljs-keyword">new</span> Object[initialCapacity];    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">this</span>.elementData = EMPTY_ELEMENTDATA;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Illegal Capacity: "</span>+                                           initialCapacity);    &#125;&#125;</code></pre><p>通过指定的初始化容量构造一个空列表。</p><h2 id="有参构造方法（二）"><a href="#有参构造方法（二）" class="headerlink" title="有参构造方法（二）"></a>有参构造方法（二）</h2><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;    elementData = c.toArray();         <span class="hljs-keyword">if</span> ((size = elementData.length) != <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span>        <span class="hljs-comment">// 每个集合的toarray()的实现方法不一样，如果不是返回 Object[] ，则需要Arrays.copyOf方法改造一下。</span>        <span class="hljs-keyword">if</span> (elementData.getClass() != Object[]<span class="hljs-class">.<span class="hljs-keyword">class</span>)            <span class="hljs-title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// replace with empty array.</span>        <span class="hljs-comment">// 用空数组替换</span>        <span class="hljs-keyword">this</span>.elementData = EMPTY_ELEMENTDATA;    &#125;&#125;</code></pre><p>通过一个Collection对象来构造列表。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>arrayList的构造方法就做一件事情，就是初始化一下储存数据的容器，其实本质上就是一个数组，在其中就叫elementData。</p><h1 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h1><h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><h3 id="add-E-e"><a href="#add-E-e" class="headerlink" title="add(E e)"></a>add(E e)</h3><p>在ArrayList尾部添加元素</p><pre><code class="hljs java"><span class="hljs-comment">/** * Appends the specified element to the end of this list. * * <span class="hljs-doctag">@param</span> e element to be appended to this list * <span class="hljs-doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="hljs-doctag">@link</span> Collection#add&#125;) */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;    <span class="hljs-comment">// 确保内部容量足够，这里是add方法，size要加1</span>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span>        <span class="hljs-comment">//在数据中正确的位置上放上元素e，并且size++</span>    elementData[size++] = e;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre><p>这里看似只有简简单单的两边，首先确保容量足够，然后加入元素。</p><p>其实不然，我们来看看<code>ensureCapacityInternal()</code>方法：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;    <span class="hljs-comment">//首先计算容量， 然后确保容量足够</span>    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125;</code></pre><p>先看计算容量的<code>calculateCapacity()</code>方法：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculateCapacity</span><span class="hljs-params">(Object[] elementData, <span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;    <span class="hljs-comment">//如果elementData是默认容量空数组，则返回minCapacity和DEFAULT_CAPACITY大的那个</span>    <span class="hljs-comment">// 调用无参构造器生成的 elementData是懒加载的，这里才开始初始化容量。</span>    <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELminCapacityEMENTDATA) &#123;        <span class="hljs-keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);    &#125;        <span class="hljs-comment">// 如果elementData不是默认容量空数组，则返回minCapacity</span>    <span class="hljs-keyword">return</span> minCapacity;&#125;</code></pre><p>在看一下<code>ensureExplicitCapacity()</code>方法：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;    <span class="hljs-comment">//modCount是为了fail-fast策略服务的，防止使用迭代器的过程中修改了ArrayList。 </span>    modCount++;        <span class="hljs-comment">// overflow-conscious code</span>    <span class="hljs-comment">// 如果容量不够，则扩容。</span>        <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)    <span class="hljs-comment">//扩容函数。</span>    grow(minCapacity);&#125;</code></pre><p>最后我们来看一下核心 <code>grow()</code>方法：</p><pre><code class="hljs java"><span class="hljs-comment">/** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * <span class="hljs-doctag">@param</span> minCapacity the desired minimum capacity */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">grow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;    <span class="hljs-comment">// overflow-conscious code    </span>    <span class="hljs-keyword">int</span> oldCapacity = elementData.length;        <span class="hljs-comment">// newCapacity 是 1.5倍 的 oldCapacity </span>    <span class="hljs-keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);    <span class="hljs-comment">// 1.5倍的 oldCapacity 不够的情况。</span>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)        newCapacity = minCapacity;    <span class="hljs-comment">//如果newCapacity超过了最大的容量限制，就调用hugeCapacity方法，也就是将能给的最大值给newCapacit</span>    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)        newCapacity = hugeCapacity(minCapacity);     <span class="hljs-comment">//newCapacity已经确定，最后扩容</span>    elementData = Arrays.copyOf(elementData, newCapacity);&#125;</code></pre><p>看一下<code>hugeCapacity()</code>方法：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hugeCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;        <span class="hljs-keyword">if</span> (minCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow， 溢出抛异常</span>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OutOfMemoryError();    <span class="hljs-comment">// 给一个能给的最大值</span>    <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE :  MAX_ARRAY_SIZE;&#125;</code></pre><p>也就是说最大也就能给到 Integer.MAX_VALUE。还是超过了这个限制，就要溢出了。相当于arraylist给了两层防护。</p><h3 id="add-int-index-E-element"><a href="#add-int-index-E-element" class="headerlink" title="add(int index, E element)"></a>add(int index, E element)</h3><p>在特定位置添加元素，也就是插入元素。</p><pre><code class="hljs java"><span class="hljs-comment">/** * Inserts the specified element at the specified position in this * list. Shifts the element currently at that position (if any) and * any subsequent elements to the right (adds one to their indices). * * <span class="hljs-doctag">@param</span> index index at which the specified element is to be inserted * <span class="hljs-doctag">@param</span> element element to be inserted * <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125; */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;    <span class="hljs-comment">//index的位置是否合理</span>    rangeCheckForAdd(index);    <span class="hljs-comment">// 确保内部容量足够</span>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span>        <span class="hljs-comment">//将elementData中从index开始的元素都后移一位</span>    System.arraycopy(elementData, index, elementData, index + <span class="hljs-number">1</span>, size - index);        <span class="hljs-comment">//插入元素</span>    elementData[index] = element;        <span class="hljs-comment">//ArrayList size + 1</span>    size++;&#125;</code></pre><p>我们来看一下<code>rangeCheckForAdd()</code>方法：</p><pre><code class="hljs java"><span class="hljs-comment">/** * A version of rangeCheck used by add and addAll. */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rangeCheckForAdd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;    <span class="hljs-comment">//下标越界 抛出异常。</span>    <span class="hljs-keyword">if</span> (index &gt; size || index &lt; <span class="hljs-number">0</span>)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));&#125;</code></pre><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>调用 add方法的逻辑 </p><p>add —&gt;  ensureCapacityInternal  —&gt;   ensureExplicitCapacity —&gt; grow —&gt;hugeCapacity</p><ol><li><p>ArrayList的默认容量10，但是这是懒加载的，只有第一次调用<code>add()</code>方法才会真正初始化。</p></li><li><p>正常情况下会扩容1.5倍，如果不够，则会扩容到所需的最小容量；如果数组的容量到了Integer.MAX_VALUE，则不会扩容了。</p></li><li><p>如果你使用<code>new ArrayList(0)</code> 来实例ArrayList对象，然后一直调用 add(E e)方法。则该实例的容量会是： 0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 - &gt; 6 -&gt; 9 …..</p></li></ol><h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><h3 id="remove-int-index"><a href="#remove-int-index" class="headerlink" title="remove(int index)"></a>remove(int index)</h3><p>删除指定位置上的元素</p><pre><code class="hljs java"><span class="hljs-comment">/** * Removes the element at the specified position in this list. * Shifts any subsequent elements to the left (subtracts one from their * indices). * * <span class="hljs-doctag">@param</span> index the index of the element to be removed * <span class="hljs-doctag">@return</span> the element that was removed from the list * <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125; */</span><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;    <span class="hljs-comment">//检查index是否合理</span>    rangeCheck(index);    <span class="hljs-comment">//是为了fail-fast策略服务的，防止使用迭代器的过程中修改了ArrayList。 </span>    modCount++;        <span class="hljs-comment">//找到应该删除的元素</span>    E oldValue = elementData(index);    <span class="hljs-comment">//计算要移动的位数。</span>    <span class="hljs-keyword">int</span> numMoved = size - index - <span class="hljs-number">1</span>;        <span class="hljs-comment">//移动元素</span>    <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)        System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index,                         numMoved);        <span class="hljs-comment">//将--size上的位置赋值为null，让gc(垃圾回收机制)更快的回收它。</span>    elementData[--size] = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// clear to let GC do its work</span>    <span class="hljs-comment">//返回删除的元素。</span>    <span class="hljs-keyword">return</span> oldValue;&#125;</code></pre><h3 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h3><p>删除指定元素</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object o)</span> </span>&#123;    <span class="hljs-comment">// 如果指定元素是null</span>    <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>; index &lt; size; index++)            <span class="hljs-comment">//找到null，并且删除</span>            <span class="hljs-keyword">if</span> (elementData[index] == <span class="hljs-keyword">null</span>) &#123;                fastRemove(index);                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>; index &lt; size; index++)            <span class="hljs-comment">//找到该元素，并且删除</span>            <span class="hljs-keyword">if</span> (o.equals(elementData[index])) &#123;                fastRemove(index);                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre><p>我们来看一下 <code>fastRemove()</code>方法：</p><pre><code class="hljs java"><span class="hljs-comment">/* * Private remove method that skips bounds checking and does not * return the value removed. */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fastRemove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;    modCount++;        <span class="hljs-comment">//找到删除的位置</span>    <span class="hljs-keyword">int</span> numMoved = size - index - <span class="hljs-number">1</span>;         <span class="hljs-comment">//移动元素</span>    <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)        System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index,                         numMoved);         <span class="hljs-comment">//将--size上的位置赋值为null，让gc(垃圾回收机制)更快的回收它。</span>    elementData[--size] = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// clear to let GC do its work</span>&#125;</code></pre><h3 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h3><p>将list中的所有元素都删除</p><pre><code class="hljs java"><span class="hljs-comment">/** * Removes all of the elements from this list.  The list will * be empty after this call returns. */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;    modCount++;    <span class="hljs-comment">// clear to let GC do its work</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)        elementData[i] = <span class="hljs-keyword">null</span>;    size = <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="removeAll"><a href="#removeAll" class="headerlink" title="removeAll()"></a>removeAll()</h3><p>删除列表中所有存在指定collection中的元素</p><pre><code class="hljs java"><span class="hljs-comment">/** * Removes from this list all of its elements that are contained in the * specified collection. * * <span class="hljs-doctag">@param</span> c collection containing elements to be removed from this list * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> true&#125; if this list changed as a result of the call * <span class="hljs-doctag">@throws</span> ClassCastException if the class of an element of this list *         is incompatible with the specified collection * <span class="hljs-doctag">@throws</span> NullPointerException if this list contains a null element and the *         specified collection does not permit null elements *         or if the specified collection is null */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">removeAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span> </span>&#123;    <span class="hljs-comment">// c不为null</span>    Objects.requireNonNull(c);        <span class="hljs-keyword">return</span> batchRemove(c, <span class="hljs-keyword">false</span>);&#125;</code></pre><p>我们来看一下<code>bachRemove()</code>方法:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">batchRemove</span><span class="hljs-params">(Collection&lt;?&gt; c, <span class="hljs-keyword">boolean</span> complement)</span> </span>&#123;    <span class="hljs-comment">// 将原集合，记名elementData    emmm，不是很理解这种操作！</span>    <span class="hljs-keyword">final</span> Object[] elementData = <span class="hljs-keyword">this</span>.elementData;        <span class="hljs-comment">// r是用来控制循环，w是保留下来的元素数量</span>    <span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>, w = <span class="hljs-number">0</span>;        <span class="hljs-comment">//elementData是否修改</span>    <span class="hljs-keyword">boolean</span> modified = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 当complement为ture,  则留下在c中存在的元素--&gt; 保留相同元素</span>        <span class="hljs-comment">// 当complement为false, 则留下在c中不存在的元素  --&gt; 删除相同元素      </span>        <span class="hljs-keyword">for</span> (; r &lt; size; r++)                        <span class="hljs-keyword">if</span> (c.contains(elementData[r]) == complement)                elementData[w++] = elementData[r];            &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-comment">// Preserve behavioral compatibility with AbstractCollection,</span>        <span class="hljs-comment">// even if c.contains() throws.</span>        <span class="hljs-comment">// 如果 c.contains()抛出异常，将剩下的元素都拷贝进去。</span>        <span class="hljs-keyword">if</span> (r != size) &#123;            System.arraycopy(elementData, r, elementData, w, size - r);            w += size - r;        &#125;                <span class="hljs-comment">//将需要保留元素外的位置 置null</span>        <span class="hljs-keyword">if</span> (w != size) &#123;            <span class="hljs-comment">// clear to let GC do its work</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = w; i &lt; size; i++)                elementData[i] = <span class="hljs-keyword">null</span>;                        modCount += size - w;            size = w;            modified = <span class="hljs-keyword">true</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> modified;&#125;</code></pre><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>remove函数用户移除指定下标的元素，此时会把指定下标到数组末尾的元素向前移动一个单位，并且会把数组最后一个元素设置为null　这样是为了方便之后将整个数组不被使用时，会被GC，可以作为小的技巧使用。</p><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><h3 id="set-int-index-E-element"><a href="#set-int-index-E-element" class="headerlink" title="set(int index, E element)"></a>set(int index, E element)</h3><p>替换指定位置的元素。</p><pre><code class="hljs java"><span class="hljs-comment">/** * Replaces the element at the specified position in this list with * the specified element. * * <span class="hljs-doctag">@param</span> index index of the element to replace * <span class="hljs-doctag">@param</span> element element to be stored at the specified position * <span class="hljs-doctag">@return</span> the element previously at the specified position * <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125; */</span><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;    <span class="hljs-comment">// 检查index是否合理</span>    rangeCheck(index);<span class="hljs-comment">// 保持旧元素</span>    E oldValue = elementData(index);    <span class="hljs-comment">// 替换新元素</span>    elementData[index] = element;    <span class="hljs-comment">// 返回旧元素</span>    <span class="hljs-keyword">return</span> oldValue;&#125;</code></pre><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><h3 id="get-int-index"><a href="#get-int-index" class="headerlink" title="get(int index)"></a>get(int index)</h3><p>获取指定位置的元素</p><pre><code class="hljs java"><span class="hljs-comment">/** * Returns the element at the specified position in this list. * * <span class="hljs-doctag">@param</span>  index index of the element to return * <span class="hljs-doctag">@return</span> the element at the specified position in this list * <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125; */</span><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;    rangeCheck(index);    <span class="hljs-keyword">return</span> elementData(index);&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">// Positional Access Operations</span><span class="hljs-function">E <span class="hljs-title">elementData</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;    <span class="hljs-keyword">return</span> (E) elementData[index];&#125;</code></pre><h2 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h2><h3 id="indexOf-Object-o"><a href="#indexOf-Object-o" class="headerlink" title="indexOf(Object o)"></a>indexOf(Object o)</h3><p>返回指定元素第一个出现的index</p><pre><code class="hljs java"><span class="hljs-comment">/** * Returns the index of the first occurrence of the specified element * in this list, or -1 if this list does not contain the element. * More formally, returns the lowest index &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;, * or -1 if there is no such index. */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(Object o)</span> </span>&#123;    <span class="hljs-comment">//如果要查找null</span>    <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)            <span class="hljs-keyword">if</span> (elementData[i]==<span class="hljs-keyword">null</span>)                <span class="hljs-keyword">return</span> i;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)            <span class="hljs-keyword">if</span> (o.equals(elementData[i]))                <span class="hljs-keyword">return</span> i;    &#125;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre><h2 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h2><h3 id="iterator-1"><a href="#iterator-1" class="headerlink" title="iterator()"></a>iterator()</h3><p>返回了一个Iterator对象</p><pre><code class="hljs java"><span class="hljs-comment">/** * Returns an iterator over the elements in this list in proper sequence. * * &lt;p&gt;The returned iterator is &lt;a href="#fail-fast"&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;. * * <span class="hljs-doctag">@return</span> an iterator over the elements in this list in proper sequence */</span><span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Itr();&#125;</code></pre><p>我们来看一下<code>Itr</code>类：</p><p><code>Itr</code>实现了<code>Iterator</code>,只能访问下一个元素，和删除元素</p><pre><code class="hljs java"><span class="hljs-comment">/** * An optimized version of AbstractList.Itr */</span><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Itr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;    <span class="hljs-comment">// 游标，下一个被返回的元素的下标</span>    <span class="hljs-keyword">int</span> cursor;       <span class="hljs-comment">// index of next element to return</span>    <span class="hljs-comment">// 最近一次返回的元素的下标，-1表示最近一次操作没有返回元素</span>    <span class="hljs-keyword">int</span> lastRet = -<span class="hljs-number">1</span>; <span class="hljs-comment">// index of last element returned; -1 if no such</span>        <span class="hljs-comment">// 为防止在使用Iterator遍历时 修改list，采用的fail-fast机制</span>    <span class="hljs-keyword">int</span> expectedModCount = modCount;    Itr() &#123;&#125;    <span class="hljs-comment">// 判断是否有 下一个</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> cursor != size;    &#125;<span class="hljs-comment">//获取下一个元素</span>    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//快速失败机制</span>        checkForComodification();                <span class="hljs-comment">// 下一个被返回的元素的下标</span>        <span class="hljs-keyword">int</span> i = cursor;                     <span class="hljs-comment">// 不能超过集合大小</span>        <span class="hljs-keyword">if</span> (i &gt;= size)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();                Object[] elementData = ArrayList.<span class="hljs-keyword">this</span>.elementData;                <span class="hljs-comment">// 不能超过容器长度</span>        <span class="hljs-keyword">if</span> (i &gt;= elementData.length)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();                <span class="hljs-comment">//跟新 cursor</span>        cursor = i + <span class="hljs-number">1</span>;                        <span class="hljs-comment">//跟新 lastRet，并且返回元素</span>        <span class="hljs-keyword">return</span> (E) elementData[lastRet = i];    &#125;    <span class="hljs-comment">// 删除最近访问的元素</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 最近一次操作必须是返回元素</span>        <span class="hljs-keyword">if</span> (lastRet &lt; <span class="hljs-number">0</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException();                 <span class="hljs-comment">//快速失败机制</span>        checkForComodification();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 删除最近一次访问的元素</span>            ArrayList.<span class="hljs-keyword">this</span>.remove(lastRet);            <span class="hljs-comment">// 跟新cursor</span>            cursor = lastRet;            <span class="hljs-comment">// 跟新lastRet，最近一次操作没有访问元素，是删除元素</span>            lastRet = -<span class="hljs-number">1</span>;                        <span class="hljs-comment">// 修改期望值</span>            expectedModCount = modCount;        &#125; <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException ex) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();        &#125;    &#125;    <span class="hljs-comment">// 剩下的每一个元素都去执行 consumer.accept()</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">forEachRemaining</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> E&gt; consumer)</span> </span>&#123;             Objects.requireNonNull(consumer);                <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> size = ArrayList.<span class="hljs-keyword">this</span>.size;        <span class="hljs-keyword">int</span> i = cursor;                <span class="hljs-comment">// 不能超过集合大小</span>        <span class="hljs-keyword">if</span> (i &gt;= size) &#123; <span class="hljs-keyword">return</span>; &#125;                <span class="hljs-keyword">final</span> Object[] elementData = ArrayList.<span class="hljs-keyword">this</span>.elementData;                <span class="hljs-comment">// 不能超过容器大小</span>        <span class="hljs-keyword">if</span> (i &gt;= elementData.length) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();        &#125;                <span class="hljs-comment">// 执行 consumer.accept方法</span>        <span class="hljs-keyword">while</span> (i != size &amp;&amp; modCount == expectedModCount) &#123;            consumer.accept((E) elementData[i++]);        &#125;                <span class="hljs-comment">// update once at end of iteration to reduce heap write traffic</span>        <span class="hljs-comment">// 为了减少写入流量在迭代结束时跟新</span>        cursor = i;        lastRet = i - <span class="hljs-number">1</span>;        <span class="hljs-comment">//快速失败机制</span>        checkForComodification();    &#125;    <span class="hljs-comment">//保证遍历时不能修改list</span>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkForComodification</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//快速失败机制，如果 modCount 和 expectedModCount不一致则抛出异常</span>        <span class="hljs-comment">//说明遍历的时候有修改list</span>        <span class="hljs-keyword">if</span> (modCount != expectedModCount)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();    &#125;&#125;</code></pre><h3 id="listIterator（）"><a href="#listIterator（）" class="headerlink" title="listIterator（）"></a>listIterator（）</h3><p>返回一个ListIterator对象</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListIterator&lt;E&gt; <span class="hljs-title">listIterator</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ListItr(<span class="hljs-number">0</span>);&#125;</code></pre><p>我们开看一下 <code>ListItr</code>：</p><p><code>ListItr</code>继承了<code>Itr</code> 实现了 <code>ListIterator</code>,不仅可以访问下一个元素，删除元素，还能访问前一个元素，增加元素</p><pre><code class="hljs java"><span class="hljs-comment">/** * An optimized version of AbstractList.ListItr */</span><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListItr</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Itr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ListIterator</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;        <span class="hljs-comment">// 可以指定访问元素的位置</span>    ListItr(<span class="hljs-keyword">int</span> index) &#123;        <span class="hljs-keyword">super</span>();        cursor = index;    &#125;<span class="hljs-comment">// 是否有前一个元素</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasPrevious</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> cursor != <span class="hljs-number">0</span>;    &#125;<span class="hljs-comment">//下一个元素位置</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nextIndex</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> cursor;    &#125;<span class="hljs-comment">//前一个元素位置</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">previousIndex</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> cursor - <span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">//获取前一个元素</span>    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">previous</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 快速失败机制</span>        checkForComodification();                <span class="hljs-comment">//前一个元素位置</span>        <span class="hljs-keyword">int</span> i = cursor - <span class="hljs-number">1</span>;                <span class="hljs-comment">//不能去到负坐标</span>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();        Object[] elementData = ArrayList.<span class="hljs-keyword">this</span>.elementData;                <span class="hljs-comment">//不能超过容器大小</span>        <span class="hljs-keyword">if</span> (i &gt;= elementData.length)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();        <span class="hljs-comment">//跟新cursor</span>        cursor = i;        <span class="hljs-comment">//跟新lastRet，并返回前一个元素</span>        <span class="hljs-keyword">return</span> (E) elementData[lastRet = i];    &#125;    <span class="hljs-comment">//将最近访问的元素设置为指定值</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(E e)</span> </span>&#123;        <span class="hljs-comment">//有最近访问的元素</span>        <span class="hljs-keyword">if</span> (lastRet &lt; <span class="hljs-number">0</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException();        <span class="hljs-comment">//快速失败机制</span>        checkForComodification();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//调用set方法</span>            ArrayList.<span class="hljs-keyword">this</span>.set(lastRet, e);        &#125; <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException ex) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();        &#125;    &#125;    <span class="hljs-comment">//在下一个元素之前，插入指定元素</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;        <span class="hljs-comment">//快速失败机制</span>        checkForComodification();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//下一个元素位置</span>            <span class="hljs-keyword">int</span> i = cursor;                        <span class="hljs-comment">//插入元素</span>            ArrayList.<span class="hljs-keyword">this</span>.add(i, e);                                   <span class="hljs-comment">//跟新cursor</span>            cursor = i + <span class="hljs-number">1</span>;                        <span class="hljs-comment">//跟新lastRet，最近一次没有访问元素</span>            lastRet = -<span class="hljs-number">1</span>;            <span class="hljs-comment">//</span>            expectedModCount = modCount;        &#125; <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException ejavax) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();        &#125;    &#125;&#125;</code></pre><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p><code>iterator()</code>返回的<code>Itr</code>实例只能访问下一个元素，删除元素；注意，在删除元素之前，必须要执行一次访问元素</p><p><code>listIterator()</code>返回的<code>ListItr</code>实例可以访问上/ 下一个元素，删除/添加/修改元素。可以添加任意个元素，但是在删除元素之前，必须执行一次访问元素。</p><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><h3 id="sort-Comparator-lt-super-E-gt-c"><a href="#sort-Comparator-lt-super-E-gt-c" class="headerlink" title="sort(Comparator&lt;? super E&gt; c)"></a>sort(Comparator&lt;? super E&gt; c)</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-keyword">super</span> E&gt; c)</span> </span>&#123;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> expectedModCount = modCount;        <span class="hljs-comment">//调用的是Arrays.sort(T[] a, int fromIndex, int toIndex, Comparator&lt;? super T&gt; c)     </span>    Arrays.sort((E[]) elementData, <span class="hljs-number">0</span>, size, c);        <span class="hljs-keyword">if</span> (modCount != expectedModCount) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();    &#125;    modCount++;&#125;</code></pre><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>底层调用的是Arrays.sort方法，对elementData数组直接排序。</p>]]></content>
      
      
      <categories>
          
          <category> 源码解读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> ArrayList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随笔</title>
      <link href="/2020/10/03/%E9%9A%8F%E7%AC%94/"/>
      <url>/2020/10/03/%E9%9A%8F%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<h2 id="java中的变量和对象："><a href="#java中的变量和对象：" class="headerlink" title="java中的变量和对象："></a>java中的变量和对象：</h2><p>对象一般是不能直接操作的，都需要通过持有它引用的 <strong>变量</strong> 来操作，值传递和引用传递是相对于变量来说的。</p><h2 id="intern"><a href="#intern" class="headerlink" title="intern()"></a>intern()</h2><pre><code class="hljs java"><span class="hljs-comment">// 当 intern 方法被调用，若池中包含一个被&#123;@link #equals(Object)&#125;方法认定为和该 String对象相等的String，</span><span class="hljs-comment">// 那么返回池中的String，否则，将该String对象添加到池中（并不一定要拷贝，也可以是引用）并返回它的引用。</span>String s1 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"he"</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">"llo"</span>);<span class="hljs-comment">// new StringBuilder().append( new String("he") ).append(  new String("llo") ).toString;</span><span class="hljs-comment">// String Pool是没有 “hello” 的，只有 “he” 和 “llo", 会在String Pool中保存一个引用，指向堆中该字符串的实例。</span><span class="hljs-comment">// s1 的实例在堆上。</span>System.out.println(s1 == s1.intern());String s3 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"abing"</span>);<span class="hljs-comment">//String Pool中有 "abing", intern()返回Pool中的实例， 而s3的实例在堆上。</span>System.out.println(s3 == s3.intern());String s4 = <span class="hljs-string">"ni hao"</span>;<span class="hljs-comment">//String Pool中有 "ni hao", intern()返回Pool中的实例， s4的实例在Pool中</span>System.out.println(s4 == s4.intern());</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>初学Java-Map</title>
      <link href="/2020/10/01/%E5%88%9D%E5%AD%A6Java-Map/"/>
      <url>/2020/10/01/%E5%88%9D%E5%AD%A6Java-Map/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Map概述"><a href="#一、Map概述" class="headerlink" title="一、Map概述"></a>一、Map概述</h1><p>Map是一种把键对象和值对象进行关联的容器。一个值对象又可以是一个Map，以此类推，这样就可以形成一个多级映射。Map容器中的键对象不允许为重复，具有唯一性。值对象则没有唯一性要求。</p><h1 id="二、通用方法"><a href="#二、通用方法" class="headerlink" title="二、通用方法"></a>二、通用方法</h1><p>下面的方法是所有实现Map接口的实现类都需要实现的方法。</p><p><strong>新增方法</strong></p><blockquote><p>V put(K key, V value))</p></blockquote><p>添加key，value到 容器中</p><pre><code class="hljs java"></code></pre><blockquote><p>void putAll(Map&lt;? extends K, ? extends V&gt; m)</p></blockquote><p>将一个map容器中的所有元素都添加进来</p><p><strong>查看方法</strong></p><blockquote><p>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</p></blockquote><p>返回map容器到一个Set集合中，以map集合中的Key=Value的形式返回到set中。</p><blockquote><p>Set<K> keySet()  </p></blockquote><p>返回map容器的所有key到一个Set集合中。</p><blockquote><p>Collection<V> values();</p></blockquote><p>返回map容器的所有value到一个集合中。</p><blockquote><p>V get(Object key)</p></blockquote><p>根据map集合中元素的Key来获取相应元素的Value</p><blockquote><p>boolean containsKey(Object key)</p></blockquote><p>判断map容器中是否包含key</p><blockquote><p>boolean containsValue(Object value)</p></blockquote><p>判断map容器中是否包含value</p><blockquote><p>boolean isEmpty()</p></blockquote><p>判断map容器是否为空</p><blockquote><p>int size()</p></blockquote><p><strong>删除方法</strong></p><blockquote><p> V remove(Object key)</p></blockquote><blockquote><p> void clear()</p></blockquote><h1 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h1><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>HashMap的底层是 <strong>数组 + 链表 / 红黑树</strong></p><pre><code class="hljs java"><span class="hljs-comment">/*** The table, initialized on first use, and resized as* necessary. When allocated, length is always a power of two.* (We also tolerate length zero in some operations to allow* bootstrapping mechanics that are currently not needed.)*/</span><span class="hljs-keyword">transient</span> Node&lt;K,V&gt;[] table;</code></pre><p>这是数组</p><pre><code class="hljs java"><span class="hljs-comment">/*** Basic hash bin node, used for most entries.  (See below for* TreeNode subclass, and in LinkedHashMap for its Entry subclass.)*/</span><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hash;    <span class="hljs-keyword">final</span> K key;    V value;    Node&lt;K,V&gt; next;&#125;</code></pre><p>这是链表</p><pre><code class="hljs java"><span class="hljs-comment">/*** Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn* extends Node) so can be used as extension of either regular or* linked node.*/</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">LinkedHashMap</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;    TreeNode&lt;K,V&gt; parent;  <span class="hljs-comment">// red-black tree links</span>    TreeNode&lt;K,V&gt; left;    TreeNode&lt;K,V&gt; right;    TreeNode&lt;K,V&gt; prev;    <span class="hljs-comment">// needed to unlink next upon deletion</span>    <span class="hljs-keyword">boolean</span> red;&#125;</code></pre><p>这是红黑树</p><hr><p>当数组元素不超过64或链表内节点不超过8时，是 <strong>数组 + 链表</strong>，否则 <strong>链表</strong> 会升级成 <strong>红黑树</strong></p><p>适用于在Map中插入、删除和定位元素。但是遍历键是无序的(如果出现有序的情况，那是你数据量太小了)。</p><pre><code class="hljs java">Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();System.out.print(<span class="hljs-string">"添加："</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;    <span class="hljs-keyword">int</span> key =(<span class="hljs-keyword">int</span>) (Math.random() * <span class="hljs-number">100</span>);    <span class="hljs-keyword">if</span>(!map.containsKey(key))&#123;        map.put(key,key);        System.out.print(key + <span class="hljs-string">"="</span> + key + <span class="hljs-string">" "</span>);    &#125;&#125;System.out.println();System.out.print(<span class="hljs-string">"查看："</span>);map.entrySet().forEach(a-&gt;&#123;System.out.print(a + <span class="hljs-string">" "</span>);&#125;);</code></pre><p>输出结果：</p><pre><code class="hljs angelscript">添加：<span class="hljs-number">46</span>=<span class="hljs-number">46</span> <span class="hljs-number">38</span>=<span class="hljs-number">38</span> <span class="hljs-number">98</span>=<span class="hljs-number">98</span> <span class="hljs-number">57</span>=<span class="hljs-number">57</span> <span class="hljs-number">30</span>=<span class="hljs-number">30</span> <span class="hljs-number">13</span>=<span class="hljs-number">13</span> <span class="hljs-number">40</span>=<span class="hljs-number">40</span> <span class="hljs-number">3</span>=<span class="hljs-number">3</span> <span class="hljs-number">6</span>=<span class="hljs-number">6</span> <span class="hljs-number">62</span>=<span class="hljs-number">62</span> 查看：<span class="hljs-number">98</span>=<span class="hljs-number">98</span> <span class="hljs-number">3</span>=<span class="hljs-number">3</span> <span class="hljs-number">38</span>=<span class="hljs-number">38</span> <span class="hljs-number">6</span>=<span class="hljs-number">6</span> <span class="hljs-number">40</span>=<span class="hljs-number">40</span> <span class="hljs-number">57</span>=<span class="hljs-number">57</span> <span class="hljs-number">13</span>=<span class="hljs-number">13</span> <span class="hljs-number">46</span>=<span class="hljs-number">46</span> <span class="hljs-number">30</span>=<span class="hljs-number">30</span> <span class="hljs-number">62</span>=<span class="hljs-number">62</span></code></pre><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>TreeMap的底层是<strong>红黑树</strong></p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Entry&lt;K,V&gt; root;</code></pre><pre><code class="hljs java"><span class="hljs-comment">/**    * Node in the Tree.  Doubles as a means to pass key-value pairs back to    * user (see Map.Entry).    */</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;    K key;    V value;    Entry&lt;K,V&gt; left;    Entry&lt;K,V&gt; right;    Entry&lt;K,V&gt; parent;    <span class="hljs-keyword">boolean</span> color = BLACK;&#125;</code></pre><p>TreeMap的底层是红黑树所有性能稍逊HashMap，但是它的遍历是有序的，是以key值排序参照。适用于按自然顺序或自定义顺序遍历键(key)</p><pre><code class="hljs java">Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> TreeMap&lt;&gt;();Random random = <span class="hljs-keyword">new</span> Random();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;    <span class="hljs-keyword">int</span> key = random.nextInt(<span class="hljs-number">100</span>);    <span class="hljs-keyword">int</span> value = random.nextInt(<span class="hljs-number">100</span>);    map.put(key,value);&#125;System.out.print(<span class="hljs-string">"key  ："</span>);map.keySet().forEach(a-&gt;&#123;System.out.printf(<span class="hljs-string">"%3d"</span>,a);&#125;);System.out.print(<span class="hljs-string">"\nvalue："</span>);map.values().forEach(a-&gt;&#123;System.out.printf(<span class="hljs-string">"%3d"</span>,a);&#125;);</code></pre><p>输出结果</p><pre><code class="hljs angelscript">key  ：  <span class="hljs-number">9</span> <span class="hljs-number">25</span> <span class="hljs-number">27</span> <span class="hljs-number">37</span> <span class="hljs-number">44</span> <span class="hljs-number">54</span> <span class="hljs-number">61</span> <span class="hljs-number">79</span> <span class="hljs-number">91</span> <span class="hljs-number">93</span>   <span class="hljs-comment">//以key为yi排序</span>value： <span class="hljs-number">26</span> <span class="hljs-number">82</span> <span class="hljs-number">23</span> <span class="hljs-number">62</span> <span class="hljs-number">94</span>  <span class="hljs-number">3</span>  <span class="hljs-number">2</span> <span class="hljs-number">16</span> <span class="hljs-number">10</span> <span class="hljs-number">75</span></code></pre><h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>LinkedHashMap是HashMap的子类。</p>]]></content>
      
      
      <categories>
          
          <category> 初学Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初学Java-Arrays</title>
      <link href="/2020/09/28/%E5%88%9D%E5%AD%A6Java-Arrays/"/>
      <url>/2020/09/28/%E5%88%9D%E5%AD%A6Java-Arrays/</url>
      
        <content type="html"><![CDATA[<h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><p>Arrays类位于 java.util 包中，是一个工具类，不能实例化，主要包含了操纵数组的各种方法(搜索、排序、复制、比较).</p><h2 id="二、常用方法"><a href="#二、常用方法" class="headerlink" title="二、常用方法"></a>二、常用方法</h2><h3 id="1-排序"><a href="#1-排序" class="headerlink" title="1.排序"></a>1.排序</h3><p>sort方法可以对数组进行排序，并且提供多种重载形式，用于满足各种类型数组的排序需要</p><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><blockquote><p>sort(int[] a) </p></blockquote><p>对<strong>基本数据类型数组</strong>的所有元素进行升序排序。</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> a[] = &#123;<span class="hljs-number">9</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">13</span>,<span class="hljs-number">3</span>,<span class="hljs-number">8</span>&#125;;Arrays.sort(a);System.out.println(Arrays.toString(a));<span class="hljs-comment">//[3, 5, 6, 8, 9, 13]</span></code></pre><hr><blockquote><p>sort(int[] a, int formIndex, int toIndex)</p></blockquote><p>对<strong>基本数据类型数组[formIndex, toIndex)范围内</strong>的元素进行升序排序</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> a[] = &#123;<span class="hljs-number">9</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">13</span>,<span class="hljs-number">3</span>,<span class="hljs-number">8</span>&#125;;Arrays.sort(a, <span class="hljs-number">1</span> , <span class="hljs-number">5</span>);System.out.println(Arrays.toString(a));<span class="hljs-comment">//[9, 3, 5, 6, 13, 8]</span></code></pre><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><blockquote><p>sort(Object[] a)</p></blockquote><p>对<strong>引用类型数组</strong>的元素进行排序，要求数组元素都实现了<strong>Comparable接口</strong></p><pre><code class="hljs java">Integer a[] = &#123;<span class="hljs-number">9</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">13</span>,<span class="hljs-number">3</span>,<span class="hljs-number">8</span>&#125;;<span class="hljs-comment">//Integer实现了Comparable接口</span>Arrays.sort(a);System.out.println(Arrays.toString(a));<span class="hljs-comment">//[3, 5, 6, 8, 9, 13]</span></code></pre><hr><blockquote><p>sort(Object[] a, int formIndex, int toIndex)</p></blockquote><p>对<strong>引用类型数组[formIndex, toIndex)范围内</strong>的元素进行排序，要求数组元素实现了<strong>Comparable接口</strong></p><pre><code class="hljs java">Integer a[] = &#123;<span class="hljs-number">9</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">13</span>,<span class="hljs-number">3</span>,<span class="hljs-number">8</span>&#125;;<span class="hljs-comment">//Integer实现了Comparable接口</span>Arrays.sort(a, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>);System.out.println(Arrays.toString(a));<span class="hljs-comment">//[9, 3, 5, 6, 13, 8]</span></code></pre><hr><blockquote><p>sort(T[] a, Comparator&lt;? super T&gt; c)</p></blockquote><p>对<strong>引用类型数组</strong>的元素进行排序，需要实现一个<strong>Comparator接口</strong> (定义排序条件)</p><pre><code class="hljs java">Integer a[] = &#123;<span class="hljs-number">9</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">13</span>,<span class="hljs-number">3</span>,<span class="hljs-number">8</span>&#125;;rrays.sort(a, (o1, o2) -&gt; &#123;<span class="hljs-keyword">return</span> o2.compareTo(o1);&#125; ); <span class="hljs-comment">//可以用lambad表达式 简化代码，这里是降序排序</span>System.out.println(Arrays.toString(a));<span class="hljs-comment">//[13, 9, 8, 6, 5, 3]</span></code></pre><hr><blockquote><p>void sort(T[] a, int fromIndex, int toIndex, Comparator&lt;? super T&gt; c)</p></blockquote><p>对<strong>引用类型数组[formIndex, toIndex)范围内</strong>的元素进行排序，需要实现一个<strong>Comparator接口</strong> (定义排序条件)</p><pre><code class="hljs java">Integer a[] = &#123;<span class="hljs-number">9</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">13</span>,<span class="hljs-number">3</span>,<span class="hljs-number">8</span>&#125;;Arrays.sort(a, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, (o1, o2) -&gt; &#123;<span class="hljs-keyword">return</span> o2.compareTo(o1);&#125;);<span class="hljs-comment">//可以用lambad表达式 简化代码，这里是降序排序</span>System.out.println(Arrays.toString(a));<span class="hljs-comment">//[9, 13, 6, 5, 3, 8]</span></code></pre><h3 id="2-搜索"><a href="#2-搜索" class="headerlink" title="2.搜索"></a>2.搜索</h3><p>binarySearch方法用来搜索指定的数组，以获得指定对象，提供多种重载形式，用于满足各种类型数组的查找需要。搜索之前，<strong>需要对数组使用sort方法进行排序。</strong></p><h4 id="基本数据类型-1"><a href="#基本数据类型-1" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><blockquote><p>int binarySearch(int[] a, int key) </p></blockquote><p>在<strong>基本数据类型数组</strong>中搜索key，返回</p><ol><li>存在key，则返回任意一个key值的下标</li><li>不存在key, 则返回 [-(插入点) - 1] 读作 [负插入点减一] (插入点：将key插入到合适位置的下标)</li></ol><pre><code class="hljs java"><span class="hljs-keyword">int</span> a[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<span class="hljs-keyword">int</span> bs10 = Arrays.binarySearch(a, <span class="hljs-number">10</span>);<span class="hljs-keyword">int</span> bs6 = Arrays.binarySearch(a, <span class="hljs-number">6</span>);<span class="hljs-keyword">int</span> bs5 = Arrays.binarySearch(a, <span class="hljs-number">5</span>);<span class="hljs-keyword">int</span> bs0 = Arrays.binarySearch(a, <span class="hljs-number">0</span>);System.out.println(<span class="hljs-string">"binarySearch: 10 = "</span> + bs10);<span class="hljs-comment">// binarySearch: 10 = -8  10应该插入到 7，-7 - 1 = -8</span>System.out.println(<span class="hljs-string">"binarySearch: 6 = "</span> + bs6);<span class="hljs-comment">//binarySearch: 6 = -6    6应该插入到 5， -5 - 1 = -6</span>System.out.println(<span class="hljs-string">"binarySearch: 5 = "</span> + bs5);<span class="hljs-comment">//binarySearch: 5 = 3   </span>System.out.println(<span class="hljs-string">"binarySearch: 0 = "</span> + bs0);<span class="hljs-comment">//binarySearch: 0 = -1    0应该插入到 0， -0 - 1 = -1</span></code></pre><hr><blockquote><p>int binarySearch(int[] a, int fromIndex, int toIndex, int key) </p></blockquote><p>在<strong>基本数据类型数组[formIndex, toIndex)范围内</strong>搜索key，返回</p><ol><li>存在key，则返回任意一个key值的下标</li><li>不存在key, 则返回 [-(插入点) - 1] 读作 [负插入点减一] (插入点：将key插入到合适位置的下标)</li></ol><p>注意：我们只在 <strong>[formIndex, toIndex)</strong> 中搜索，所有的插入点只能在 <strong>[formIndex, toIndex]</strong>中</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> a[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<span class="hljs-keyword">int</span> bs10 = Arrays.binarySearch(a,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>, <span class="hljs-number">10</span>);<span class="hljs-keyword">int</span> bs6 = Arrays.binarySearch(a,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>);<span class="hljs-keyword">int</span> bs5 = Arrays.binarySearch(a,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>, <span class="hljs-number">5</span>);<span class="hljs-keyword">int</span> bs0 = Arrays.binarySearch(a,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>, <span class="hljs-number">0</span>);System.out.println(<span class="hljs-string">"binarySearch: 10 = "</span> + bs10);<span class="hljs-comment">// binarySearch: 10 = -6 只能将10插入到 5， -5 - 1 = -6</span>System.out.println(<span class="hljs-string">"binarySearch: 6 = "</span> + bs6);<span class="hljs-comment">// binarySearch: 6 = -6  只能将6 插入到 5， -5 - 1 = -6</span>System.out.println(<span class="hljs-string">"binarySearch: 5 = "</span> + bs5);<span class="hljs-comment">// binarySearch: 5 = 3</span>System.out.println(<span class="hljs-string">"binarySearch: 0 = "</span> + bs0)<span class="hljs-comment">// binarySearch: 0 = -2 只能将0 插入到 1， -1 - 1 = -2</span></code></pre><h4 id="引用类型-1"><a href="#引用类型-1" class="headerlink" title="引用类型"></a>引用类型</h4><blockquote><p>int binarySearch(Object[] a, Object key) </p></blockquote><p>在<strong>引用类型数组</strong>里搜索key，要求数组元素实现Comparable接口，返回值参照<code>int binarySearch(int[] a, int key)</code> 方法</p><pre><code class="hljs java">Integer a[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<span class="hljs-comment">//Integer自己实现了Comparable接口</span><span class="hljs-keyword">int</span> bs10 = Arrays.binarySearch(a, <span class="hljs-number">10</span>);<span class="hljs-keyword">int</span> bs6 = Arrays.binarySearch(a, <span class="hljs-number">6</span>);<span class="hljs-keyword">int</span> bs5 = Arrays.binarySearch(a, <span class="hljs-number">5</span>);<span class="hljs-keyword">int</span> bs0 = Arrays.binarySearch(a, <span class="hljs-number">0</span>);System.out.println(<span class="hljs-string">"binarySearch: 10 = "</span> + bs10);<span class="hljs-comment">// binarySearch: 10 = -8  10应该插入到 7，-7 - 1 = -8</span>System.out.println(<span class="hljs-string">"binarySearch: 6 = "</span> + bs6);<span class="hljs-comment">//binarySearch: 6 = -6    6应该插入到 5， -5 - 1 = -6</span>System.out.println(<span class="hljs-string">"binarySearch: 5 = "</span> + bs5);<span class="hljs-comment">//binarySearch: 5 = 3   </span>System.out.println(<span class="hljs-string">"binarySearch: 0 = "</span> + bs0);<span class="hljs-comment">//binarySearch: 0 = -1    0应该插入到 0， -0 - 1 = -1</span></code></pre><hr><blockquote><p>int binarySearch(Object[] a, int fromIndex, int toIndex, Object key) </p></blockquote><p>在<strong>引用类型数组[formIndex, toIndex)范围内</strong>搜索key，要求数组元素实现Comparable接口，返回值参照<code>int binarySearch(int[] a, int fromIndex, int toIndex, int key)</code>方法</p><pre><code class="hljs java">Integer a[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<span class="hljs-comment">//Integer自己实现了Comparable接口</span><span class="hljs-keyword">int</span> bs10 = Arrays.binarySearch(a,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>, <span class="hljs-number">10</span>);<span class="hljs-keyword">int</span> bs6 = Arrays.binarySearch(a,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>);<span class="hljs-keyword">int</span> bs5 = Arrays.binarySearch(a,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>, <span class="hljs-number">5</span>);<span class="hljs-keyword">int</span> bs0 = Arrays.binarySearch(a,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>, <span class="hljs-number">0</span>);System.out.println(<span class="hljs-string">"binarySearch: 10 = "</span> + bs10);<span class="hljs-comment">// binarySearch: 10 = -6 只能将10插入到 5， -5 - 1 = -6</span>System.out.println(<span class="hljs-string">"binarySearch: 6 = "</span> + bs6);<span class="hljs-comment">// binarySearch: 6 = -6  只能将6 插入到 5， -5 - 1 = -6</span>System.out.println(<span class="hljs-string">"binarySearch: 5 = "</span> + bs5);<span class="hljs-comment">// binarySearch: 5 = 3</span>System.out.println(<span class="hljs-string">"binarySearch: 0 = "</span> + bs0)<span class="hljs-comment">// binarySearch: 0 = -2 只能将0 插入到 1， -1 - 1 = -2</span></code></pre><h3 id="3-填充"><a href="#3-填充" class="headerlink" title="3.填充"></a>3.填充</h3><p>fill方法是填充数组，提供多种重载形式，用于满足各种类型数组的填充需要。</p><h4 id="基本数据类型-2"><a href="#基本数据类型-2" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><blockquote><p> void fill(int[] a, int val)</p></blockquote><p>在<strong>基本数据类型数组</strong>中填充指定值val。</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> a[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">6</span>];Arrays.fill(a,<span class="hljs-number">3</span>);System.out.println(Arrays.toString(a));<span class="hljs-comment">//[3, 3, 3, 3, 3, 3]</span></code></pre><hr><blockquote><p> void fill(int[] a, int fromIndex, int toIndex, int val)</p></blockquote><p>在<strong>基本数据类型数组[formIndex, toIndex)范围内</strong>中填充指定值val。</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> a[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">6</span>];Arrays.fill(a, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>);System.out.println(Arrays.toString(a));<span class="hljs-comment">//[0, 0, 3, 3, 3, 0]</span></code></pre><h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><blockquote><p> void fill(Object[] a, Object val)</p></blockquote><p>在<strong>引用类型数组</strong>中填充指定对象val。</p><pre><code class="hljs java">Integer a[] = <span class="hljs-keyword">new</span> Integer[<span class="hljs-number">6</span>];Arrays.fill(a, <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">3</span>));System.out.println(Arrays.toString(a));<span class="hljs-comment">//[3, 3, 3, 3, 3, 3]</span></code></pre><hr><blockquote><p> void fill(Object[] a, int fromIndex, int toIndex, Object val)</p></blockquote><pre><code class="hljs java">在**引用类型数组[formIndex, toIndex)范围内**中填充指定对象val。```javaInteger a[] = <span class="hljs-keyword">new</span> Integer[<span class="hljs-number">6</span>];Arrays.fill(a, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">3</span>));System.out.println(Arrays.toString(a));<span class="hljs-comment">//[0, 0, 3, 3, 3, 0]</span></code></pre><h3 id="4-复制"><a href="#4-复制" class="headerlink" title="4.复制"></a>4.复制</h3><p>copyOf方法和copyOfRange方法可以拷贝一个数组副本，提供多种重载形式，用于满足各种类型数组的复制需要。</p><h4 id="基本数据类型-3"><a href="#基本数据类型-3" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><blockquote><p>int[] copyOf(int[] original, int newLength)<br>返回一个长度为newLength的数组，</p></blockquote><p>如果newLeng大于源数组的长度，多余的元素为0值;</p><p>如果newLeng小于源数组的长度，只拷贝源数组前面一部分的元素。</p><h4 id="引用类型-2"><a href="#引用类型-2" class="headerlink" title="引用类型"></a>引用类型</h4><blockquote><p><T> T[] copyOf(T[] original, int newLength)</p></blockquote><p>返回一个和源数组同一类型，长度为newLength的数组</p>]]></content>
      
      
      <categories>
          
          <category> 初学Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具类 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初学java-JDBC</title>
      <link href="/2020/01/17/%E5%88%9D%E5%AD%A6java-JDBC/"/>
      <url>/2020/01/17/%E5%88%9D%E5%AD%A6java-JDBC/</url>
      
        <content type="html"><![CDATA[<p>初学java-JDBC所做小结</p><a id="more"></a><h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><p>　* JDBC（Java Data Base Connectivity,java数据库连接）是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。是Java访问数据库的标准规范<br>　* JDBC提供了一种基准,据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序。<br>　* DBC需要连接驱动，驱动是两个设备要进行通信，满足一定通信数据格式，数据格式由设备提供商规定，设备提供商为设备提供驱动软件，通过软件可以与该设备进行通信。<br>　* Java提供访问数据库规范称为JDBC，而生产厂商提供规范的实现类称为驱动。JDBC是接口，驱动是接口的实现类，没有驱动将无法完成数据库连接，从而不能操作数据库！每个数据库厂商都需要提供自己的驱动，用来连接自己公司的数据库，也就是说驱动一般都由数据库生成厂商提供。</p><h3 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h3><p>　1. 初始化驱动.<br>　　　告知JVM使用的是哪一个数据库的驱动<br>　2. 建立连接.<br>     使用JDBC中的类，完成对MySQL数据库的连接<br>　3. 获得语句执行平台,执行sql语句<br>　　　通过连接对象获取对SQL语句的执行者对象,使用执行者对象，向数据库执行SQL语句  获取到数据库的执行后的结果<br>　4. 处理结果<br>　5. 释放资源.</p><h4 id="初始化驱动"><a href="#初始化驱动" class="headerlink" title="初始化驱动"></a>初始化驱动</h4><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;        Class.forName(<span class="hljs-string">"com.mysql.jdbc.Driver"</span>);        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;             e.printStackTrace();        &#125;&#125;</code></pre><p>初始化驱动类com.mysql.jdbc.Driver，该类就在 mysql-connector-java-5.0.8-bin.jar中。如果你使用的是oracle数据库那么该驱动类将不同。<br>Class.forName是把这个类加载到JVM中，加载的时候，就会执行其中的静态初始化块，完成驱动的初始化的相关工作。</p><h4 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h4><pre><code class="hljs java">Connection conn = DriverManager.getConnection(<span class="hljs-string">"jdbc:mysql://localhost:3306/demo"</span>, <span class="hljs-string">"root"</span>, <span class="hljs-string">"1234"</span>);</code></pre><p>1.这里连接的是本地数据库 localhost<br>2.Mysql数据库的端口号：3306<br>3.数据库表名 demo（填自己的数据库表名）<br>4.账号  （填写自己的账号）<br>5.密码  （填写自己的密码）</p><p>Connection是与特定数据库连接回话的接口，使用的时候需要导包，而且必须在程序结束的时候将其关闭。getConnection方法也需要捕获SQLException异常。</p><h4 id="创建Statement或者PreparedStatement接口-执行语句"><a href="#创建Statement或者PreparedStatement接口-执行语句" class="headerlink" title="创建Statement或者PreparedStatement接口,执行语句"></a>创建Statement或者PreparedStatement接口,执行语句</h4><ul><li><p>Statement接口：</p><pre><code class="hljs java">Statement s = conn.createStatement();<span class="hljs-comment">// 准备sql语句</span><span class="hljs-comment">// 注意： 字符串要用单引号'</span>String name = <span class="hljs-string">"二狗"</span>;String sql = <span class="hljs-string">"insert into user(id,uname) values ("</span>+<span class="hljs-number">1</span>+<span class="hljs-string">",'"</span>+name+<span class="hljs-string">"')"</span>;<span class="hljs-comment">//在statement中使用字符串拼接的方式，这种方式存在诸多问题</span>s.execute(sql);System.out.println(<span class="hljs-string">"执行插入语句成功"</span>);</code></pre><p>Statement接口创建之后，可以执行SQL语句，完成对数据库的增删改查。其中 ，增删改只需要改变SQL语句的内容就能完成，然而查询略显复杂。<br>字符串拼接方式的SQL语句是非常繁琐的，中间有很多的单引号和双引号的混用，极易出错</p></li><li><p>PreparedStatemet接口：</p><pre><code class="hljs java">String sql = <span class="hljs-string">"insert into user (id,uname,pwd,regTime) values (?,?,66666,?)"</span>; <span class="hljs-comment">//该语句为每个 IN 参数保留一个问号（“？”）作为占位符</span>PreparedStatement ps = coon.preparedStatemtent(sql);ps.setObject(<span class="hljs-number">1</span>, <span class="hljs-string">"123"</span>); <span class="hljs-comment">//给占位符赋值</span>ps.setObject(<span class="hljs-number">2</span>, <span class="hljs-string">"麻子"</span>); <span class="hljs-comment">//给占位符赋值</span>ps.setObject(<span class="hljs-number">3</span>, <span class="hljs-keyword">new</span> java.sql.Date(System.currentTimeMillis()));  <span class="hljs-comment">//给占位符赋值</span>ps.execute(); <span class="hljs-comment">//执行</span></code></pre><p>使用PreparedStatement时，他的SQL语句不再采用字符串拼接的方式，而是采用占位符的方式。“？”在这里就起到占位符的作用。这种方式除了避免了statement拼接字符串的繁琐之外，还能够提高性能。每次SQL语句都是一样的，java类就不会再次编译，这样能够显著提高性能。</p></li></ul><p><strong>Statement和PreparedStatement的异同及优缺点</strong><br>同：两者都是用来执SQL语句的<br>异：PreparedStatement需要根据SQL语句来创建，它能够通过设置参数，指定相应的值，不是像Statement那样使用字符串拼接的方式。</p><p><strong>PreparedStatement的优点：</strong><br>1、其使用参数设置，可读性好，不易记错。在statement中使用字符串拼接，可读性和维护性比较差。<br>2、其具有预编译机制，性能比statement更快。<br>3、其能够有效防止SQL注入攻击。</p><h4 id="处理结果"><a href="#处理结果" class="headerlink" title="处理结果"></a>处理结果</h4><pre><code class="hljs java">String sql = <span class="hljs-string">"select id,uname,pwd from user where id&gt;?"</span>;PrepareStatement ps = conn.prepareStatement(sql);ps.setObject(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">//把id大于2的记录都取出来</span>ResultSet rs = ps.executeQuery();<span class="hljs-keyword">while</span>(rs.next()) &#123;System.out.println(rs.getInt(<span class="hljs-string">"id"</span>)+<span class="hljs-string">"--"</span>+rs.getString(<span class="hljs-string">"uname"</span>));&#125;</code></pre><p>利用While(ResultSet.next()){…}循环将集合ResultSet中的结果遍历出来。</p><p>ResultSet.getXX();     这里的get方法的括号里面可以填属性值，如下图代码中的course_id,还可以填该属性在数据表中的列号，从1开始编码，例如：course_id在我的t-courses数据表中位于第一列，所以执行get方法的时候，我除了代码段中写法外，还可以这样写int courseId = rs.getInt(1);但是不推荐使用列号的这种方式，因为一段数据表中个属性值得顺序发生变化，就会导致这里出错，而使用属性名则不会出现这样的问题。</p><h4 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h4><p>在JDBC编码的过程中我们创建了Connection、ResultSet等资源，这些资源在使用完毕之后是一定要进行关闭的。关闭的过程中遵循从里到外的原则。</p>]]></content>
      
      
      <categories>
          
          <category> 初学Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GOF32</title>
      <link href="/2020/01/16/GOF32-%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/01/16/GOF32-%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><ul><li>分离了对象子组件的单独构造（由 Builder 来负责）和装配（由 Director 负责）。从而可以构造出复杂的对象。这个模式适用于：某个对象的构建过程复杂的情况下使用。</li><li>由于时下按了构建和装配的解耦。不同的构建起，相同的装配，也可以做出不同的对象；相同的构建起，不同的装配顺序也可以做出不同的对象。也就算实现了构建算法、装配算法的解耦，实现了更好的复用。</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AirShip</span> </span>&#123;<span class="hljs-keyword">private</span> OrbitalModule orbitalModule; <span class="hljs-comment">// 轨道舱</span><span class="hljs-keyword">private</span> Engine engine; <span class="hljs-comment">// 发动机</span><span class="hljs-keyword">private</span> EscapeTower escapeTower; <span class="hljs-comment">// 逃逸塔</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">launch</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"发射！"</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> OrbitalModule <span class="hljs-title">getOrbitalModule</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> orbitalModule;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setOrbitalModule</span><span class="hljs-params">(OrbitalModule orbitalModule)</span> </span>&#123;<span class="hljs-keyword">this</span>.orbitalModule = orbitalModule;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> Engine <span class="hljs-title">getEngine</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> engine;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEngine</span><span class="hljs-params">(Engine engine)</span> </span>&#123;<span class="hljs-keyword">this</span>.engine = engine;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> EscapeTower <span class="hljs-title">getEscapeTower</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> escapeTower;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEscapeTower</span><span class="hljs-params">(EscapeTower escapeTower)</span> </span>&#123;<span class="hljs-keyword">this</span>.escapeTower = escapeTower;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrbitalModule</span> </span>&#123;<span class="hljs-keyword">private</span> String name;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OrbitalModule</span><span class="hljs-params">(String name)</span> </span>&#123;<span class="hljs-keyword">this</span>.name = name;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> name;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<span class="hljs-keyword">this</span>.name = name;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Engine</span> </span>&#123;<span class="hljs-keyword">private</span> String name;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Engine</span><span class="hljs-params">(String name)</span> </span>&#123;<span class="hljs-keyword">this</span>.name = name;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> name;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<span class="hljs-keyword">this</span>.name = name;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EscapeTower</span> </span>&#123;<span class="hljs-keyword">private</span> String name;<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> name;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<span class="hljs-keyword">this</span>.name = name;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EscapeTower</span><span class="hljs-params">(String name)</span> </span>&#123;<span class="hljs-keyword">super</span>();<span class="hljs-keyword">this</span>.name = name;&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AirShipBuilder</span> </span>&#123;<span class="hljs-function">Engine <span class="hljs-title">builderEngine</span><span class="hljs-params">()</span></span>;<span class="hljs-function">OrbitalModule <span class="hljs-title">builderOrbitalModule</span><span class="hljs-params">()</span></span>;<span class="hljs-function">EscapeTower <span class="hljs-title">builderEscapeTower</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AirShipDirector</span> </span>&#123;<span class="hljs-comment">/** * 组装飞船对象 * <span class="hljs-doctag">@return</span> */</span><span class="hljs-function">AirShip <span class="hljs-title">directAirShip</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbinAirShipBuilder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AirShipBuilder</span> </span>&#123;<span class="hljs-comment">//StringBuilder, 以后学习XML解析中，JDOM库中的类：DomBuilder,SaxBuilder</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Engine <span class="hljs-title">builderEngine</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"构建发动机！"</span>);<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Engine(<span class="hljs-string">"Abin发动机！"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> EscapeTower <span class="hljs-title">builderEscapeTower</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"构建逃逸塔"</span>);<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> EscapeTower(<span class="hljs-string">"Abin逃逸塔"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> OrbitalModule <span class="hljs-title">builderOrbitalModule</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"构建轨道舱"</span>);<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> OrbitalModule(<span class="hljs-string">"Abin轨道舱"</span>);&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbinAirshipDirector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AirShipDirector</span> </span>&#123;<span class="hljs-keyword">private</span> AirShipBuilder builder;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AbinAirshipDirector</span><span class="hljs-params">(AirShipBuilder builder)</span> </span>&#123;<span class="hljs-keyword">this</span>.builder = builder;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> AirShip <span class="hljs-title">directAirShip</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//装配成飞船对象</span>AirShip ship = <span class="hljs-keyword">new</span> AirShip();ship.setEngine(builder.builderEngine());ship.setEscapeTower(builder.builderEscapeTower());ship.setOrbitalModule(builder.builderOrbitalModule());<span class="hljs-keyword">return</span> ship;&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        AirShipDirector director=<span class="hljs-keyword">new</span> AbinAirshipDirector(<span class="hljs-keyword">new</span> AbinAirShipBuilder());        AirShip ship = director.directAirShip();        System.out.println(ship.getEngine().getName());    &#125;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> GOF32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GOF32-工厂模式</title>
      <link href="/2020/01/15/GOF32-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/01/15/GOF32-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>GOF32-工厂模式</p><a id="more"></a><h3 id="面向对象设计的基本原则："><a href="#面向对象设计的基本原则：" class="headerlink" title="面向对象设计的基本原则："></a>面向对象设计的基本原则：</h3><ul><li>OCP（开闭原则，Open-Closed Principle）：一个软件的实体应当对扩展开放，对修改关闭。</li><li>DIP（依赖倒转原则，Dependence Inversion Principle）：要针对接口编程，不要针对实现编程。</li><li>LoD（迪米特法则，Law of Demeter）：只与你直接的朋友通信，而避免和陌生人通信。<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3>实现了创建者和调用者的分离<br>有简单工厂，工厂方法，抽象工厂</li></ul><h4 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h4><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Car</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Audi</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Car</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"我是奥迪！"</span>);&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Byd</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Car</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"我是比亚迪！"</span>);&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CarFactory</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Car <span class="hljs-title">createCar</span><span class="hljs-params">(String type)</span> </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-string">"奥迪"</span>.equals(type)) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Audi();&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"比亚迪"</span>.equals(type)) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Byd();&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client02</span> </span>&#123; <span class="hljs-comment">// 调用者</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;CarFactory.createCar(<span class="hljs-string">"奥迪"</span>).run();CarFactory.createCar(<span class="hljs-string">"比亚迪"</span>).run();&#125;&#125;</code></pre><h4 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h4><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Car</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Audi</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Car</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"我是奥迪！"</span>);&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Byd</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Car</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"我是比亚迪！"</span>);&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CarFactory</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> Car <span class="hljs-title">createCar</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AudiFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CarFactory</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Car <span class="hljs-title">createCar</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Audi();&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BydFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CarFactory</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Car <span class="hljs-title">createCar</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Byd();&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">new</span> AudiFactory().createCar().run();<span class="hljs-keyword">new</span> BydFactory().createCar().run();&#125;&#125;</code></pre><h4 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h4><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Engine</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LuxuryEngine</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Engine</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"转的快！"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"启动快!可以自动启停！"</span>);&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LowEngine</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Engine</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"转的慢！"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"启动慢!"</span>);&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Seat</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">massage</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LuxurySeat</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Seat</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">massage</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"可以自动按摩！"</span>);&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LowSeat</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Seat</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">massage</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"不能按摩！"</span>);&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Tyre</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">revolve</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LuxuryTyre</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Tyre</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">revolve</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"旋转不磨损！"</span>);&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LowTyre</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Tyre</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">revolve</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"旋转磨损快！"</span>);&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CarFactory</span> </span>&#123;<span class="hljs-function">Engine <span class="hljs-title">createEngine</span><span class="hljs-params">()</span></span>;<span class="hljs-function">Seat <span class="hljs-title">createSeat</span><span class="hljs-params">()</span></span>;<span class="hljs-function">Tyre <span class="hljs-title">createTyre</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LuxuryCarFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CarFactory</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Engine <span class="hljs-title">createEngine</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LuxuryEngine();&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Seat <span class="hljs-title">createSeat</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LuxurySeat();&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Tyre <span class="hljs-title">createTyre</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LuxuryTyre();&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LowCarFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CarFactory</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Engine <span class="hljs-title">createEngine</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LowEngine();&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Seat <span class="hljs-title">createSeat</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LowSeat();&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Tyre <span class="hljs-title">createTyre</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LowTyre();&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;CarFactory factory = <span class="hljs-keyword">new</span> LuxuryCarFactory();Engine engine = factory.createEngine();Seat seat = factory.createSeat();Tyre tyre = factory.createTyre();&#125;&#125;</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>简单工厂模式：虽然某种程度不符合设计原则，但实际使用最多</li><li>工厂方法模式：不修改已有类的前提下，通过增加新的工厂类实现扩展。</li><li>抽象工厂模式：不可以增加产品，可以增加产品族</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>JDK 中 Calendar 的 getInstance 方法</li><li>JDBC 中 Connection 对象的获取</li><li>Hibernate 中 SessionFactory 创建 Session</li><li>Spring 中 IOC 容器创建管理 bean对象</li><li>XML 解析时的 DocumentBuilderFactory 创建解析器对象</li><li>反射中 Class 对象的 newInstance()</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> GOF32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GOF32-单例模式</title>
      <link href="/2020/01/14/GOF32-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/01/14/GOF32-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>GOF32-单例模式</p><a id="more"></a><h3 id="单利模式"><a href="#单利模式" class="headerlink" title="单利模式"></a>单利模式</h3><ul><li>保证一个类只有一个实例，并且提供一个访问该实例的全局访问点。</li><li>由于单例模式只生成一个实例，减少了系统性能开销。单例模式可以在系统设置全局的访问点，优化共享资源访问。例如可以设计一个单例类，负责所有数据表的映射处理。</li></ul><h3 id="常见五种单例模式"><a href="#常见五种单例模式" class="headerlink" title="常见五种单例模式"></a>常见五种单例模式</h3><p>饿汉式，懒汉式，双重检测锁，静态内部类，枚举单例。</p><h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><p>线程安全，调用效率高，但不能不能延时加载</p><pre><code class="hljs java"><span class="hljs-comment">/** * 测试饿汉式单例模式 * <span class="hljs-doctag">@author</span> Abin */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonDemo1</span> </span>&#123;<span class="hljs-comment">//类初始化时，立即加载这个对象(没有延时加载的优势)。加载类时，天然的是线程安全的！</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingletonDemo1 instance = <span class="hljs-keyword">new</span> SingletonDemo1();<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonDemo1</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// 私有化构造器</span>&#125;<span class="hljs-comment">//方法没有同步，调用效率高！</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonDemo1  <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> instance;&#125;&#125;</code></pre><h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><p>线程安全，调用小路不高，可以延时加载。</p><pre><code class="hljs java"><span class="hljs-comment">/** * 测试懒汉式单例模式 * <span class="hljs-doctag">@author</span> Abin */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonDemo2</span> </span>&#123;<span class="hljs-comment">//类初始化时，不初始化这个对象（延时加载，真正用的时候再创建）。</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingletonDemo2 instance;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonDemo2</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 私有化构造器</span>&#125;<span class="hljs-comment">//方法同步，调用效率低！</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> SingletonDemo2 <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;instance = <span class="hljs-keyword">new</span> SingletonDemo2();&#125;<span class="hljs-keyword">return</span> instance;&#125;&#125;</code></pre><h4 id="双重检测锁"><a href="#双重检测锁" class="headerlink" title="双重检测锁"></a>双重检测锁</h4><p>由于JVM底层内部模型原因，偶尔会出现问题，不建议使用</p><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>线程安全，调用效率高，可以延时加载。</p><pre><code class="hljs java"><span class="hljs-comment">/** * 测试静态内部类实现单例模式 这种方式：线程安全，调用效率高，并且实现了延时加载！ * <span class="hljs-doctag">@author</span> Abin * */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonDemo4</span> </span>&#123; <span class="hljs-comment">//使用一个静态的内部类来创建实例，SingletonClassInstance.getInstance时才会初始化</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonClassInstance</span> </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> SingletonDemo4 instance = <span class="hljs-keyword">new</span>   SingletonDemo4();&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonDemo4</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//私有化构造方法</span>&#125;<span class="hljs-comment">//方法没有同步，调用效率高！</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonDemo4 <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> SingletonClassInstance.instance;&#125;&#125;</code></pre><h4 id="枚举单例"><a href="#枚举单例" class="headerlink" title="枚举单例"></a>枚举单例</h4><p>线程安全、调用效率高，不能延时加载（天然防治反射和反序列化的漏洞）</p><pre><code class="hljs java"><span class="hljs-comment">/** * 测试枚举式实现单例模式(没有延时加载) * <span class="hljs-doctag">@author</span> Abin */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> SingletonDemo5 &#123;<span class="hljs-comment">//这个枚举元素，本身就是单例对象！</span>INSTANCE;<span class="hljs-comment">//添加自己需要的操作！</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">singletonOperation</span><span class="hljs-params">()</span> </span>&#123;&#125;&#125;</code></pre><h3 id="破解单例模式"><a href="#破解单例模式" class="headerlink" title="破解单例模式"></a>破解单例模式</h3><h4 id="反射破解单例模式"><a href="#反射破解单例模式" class="headerlink" title="反射破解单例模式"></a>反射破解单例模式</h4><pre><code class="hljs java"><span class="hljs-comment">/** * 测试反射破解单例模式（静态内部类法） * <span class="hljs-doctag">@author</span> Abin */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client2</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;SingletonDemo4 s1 = SingletonDemo4.getInstance();SingletonDemo4 s2 = SingletonDemo4.getInstance();System.out.println(s1 == s2); <span class="hljs-comment">// true;</span><span class="hljs-comment">//通过反射的方式直接调用私有构造器</span>Class clazz = Class.forName(<span class="hljs-string">"com.bjsxt.singleton.SingletonDemo4"</span>);Constructor c = clazz.getDeclaredConstructor(<span class="hljs-keyword">null</span>);c.setAccessible(<span class="hljs-keyword">true</span>);SingletonDemo4  s3 = (SingletonDemo4) c.newInstance();SingletonDemo4  s4 = (SingletonDemo4) c.newInstance();System.out.println(s3 == s4);  <span class="hljs-comment">//false</span>&#125;</code></pre><h4 id="反序列化破解单例模式"><a href="#反序列化破解单例模式" class="headerlink" title="反序列化破解单例模式"></a>反序列化破解单例模式</h4><pre><code class="hljs java"><span class="hljs-comment">/** * 测试反序列化破解单例模式（静态内部类法） * <span class="hljs-doctag">@author</span> Abin */</span>SingletonDemo4 s1 = SingletonDemo4.getInstance();SingletonDemo4 s1 = SingletonDemo4.getInstance();SingletonDemo4 s2 = SingletonDemo4.getInstance();System.out.println(s1 == s2); <span class="hljs-comment">// true;</span><span class="hljs-comment">//将s1序列化保存</span>FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">"d:/a.txt"</span>);ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(fos);oos.writeObject(s1);oos.close();fos.close();<span class="hljs-comment">//通过反序列化的方式构造多个对象 </span>ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"d:/a.txt"</span>));SingletonDemo4 s2 = (SingletonDemo4) ois.readObject();System.out.println(s1==s3); <span class="hljs-comment">// false</span></code></pre><h3 id="防止反射与反序列化的漏洞"><a href="#防止反射与反序列化的漏洞" class="headerlink" title="防止反射与反序列化的漏洞"></a>防止反射与反序列化的漏洞</h3><pre><code class="hljs java"><span class="hljs-comment">/** * 测试懒汉式单例模式(如何防止反射和反序列化漏洞) * <span class="hljs-doctag">@author</span> Abin */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonDemo6</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<span class="hljs-comment">//类初始化时，不初始化这个对象（延时加载，真正用的时候再创建）。</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingletonDemo6 instance;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonDemo6</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 私有化构造器</span><span class="hljs-keyword">if</span> (instance != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">//构造器中抛出异常</span><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException();  &#125;<span class="hljs-comment">//方法同步，调用效率低！</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> SingletonDemo6 <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;instance = <span class="hljs-keyword">new</span> SingletonDemo6();&#125;<span class="hljs-keyword">return</span> instance;&#125;<span class="hljs-comment">//反序列化时，如果定义了readResolve()则直接返回此方法指定的对象。而不需要单独再创建新对象！</span><span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">readResolve</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ObjectStreamException </span>&#123;<span class="hljs-keyword">return</span> instance;&#125;&#125;</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>当需要单例对象，占用资源少，不需要延时加载时，枚举式优于饿汉式</li><li>当需要单例对象，占用资源少，需要延时加载时，静态内部类优于懒汉式</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>Windows的Task Manager(任务管理器)</li><li>Windows的Recycle Bin(回收站)</li><li>应用程序的日志应用</li><li>数据库连接池</li><li>操作系统的文件系统，一个操作系统只能有一个文件系统</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> GOF32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java类加载机制</title>
      <link href="/2019/12/31/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/12/31/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>浅谈Java类加载机制，虚拟机如何加载Class文件。</p><a id="more"></a><p>先贴出一段代码，请思考一下输出结果</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> Java;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassOfLoading</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Son s = <span class="hljs-keyword">new</span> Son();&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span></span>&#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> f  ;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Son son = <span class="hljs-keyword">new</span> Son();<span class="hljs-keyword">static</span> &#123;f = <span class="hljs-number">10</span>;System.out.println(<span class="hljs-string">"Father静态块 ,f="</span> + f);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Father</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"Father构造器 ,f="</span> + f);&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span></span>&#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> s;<span class="hljs-keyword">static</span> &#123;s = <span class="hljs-number">12</span>;System.out.println(<span class="hljs-string">"Son静态块 ,s="</span> + s);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Son</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"Son构造器 ,s="</span> + s);&#125;&#125;</code></pre><h3 id="java虚拟机类加载机制"><a href="#java虚拟机类加载机制" class="headerlink" title="java虚拟机类加载机制"></a>java虚拟机类加载机制</h3><p>虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。<br>在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，所以Java可以动态扩展的语言特性(c++是静态语言)就是依赖运行期动态加载和动态链接这个特点实现的。</p><h3 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h3><p>类的生命周期(从被加载到虚拟机内存开始，到卸载出内存为止)有七个阶段：<br>加载，验证，准备，解析，初始化，使用，卸载</p><p>加载，验证，准备，初始化，卸载 的顺序是确定的，必须按这个流程开始(只是开始！！！)。</p><p>java虚拟机规范中没有强制约束什么情况下需要开始 加载。但是严格规定了有且只有五种情况必须立即对类进行 初始化 (那么加载，验证，准备一定会在此之前开始)：</p><ol><li>遇到new，getstatic，putstatic，invakestatic 这4条字节码指令时，如果类没有进行初始化，则需要先触发初始化。也就是使用new关键字实例化对象的时候，读取,设置一个类的静态字段的时候，以及调用一个类的静态方法时。</li><li>当虚拟机启动时，会初始化主类（包含main()方法的类）<br>（省略以下3条）</li></ol><h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3>]]></content>
      
      
      
        <tags>
            
            <tag> “Java” </tag>
            
            <tag> 类加载机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初学Java-多线程</title>
      <link href="/2019/12/16/%E5%88%9D%E5%AD%A6Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2019/12/16/%E5%88%9D%E5%AD%A6Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>看完 <a href="https://www.cnblogs.com/xiaoxi/" target="_blank" rel="noopener">平凡希</a> 大佬的<a href="https://www.cnblogs.com/xiaoxi/p/7581899.html" target="_blank" rel="noopener">《java多线程基础总结》</a> ，结合总结的所学，写出的一篇关于java多线程基础的文章</p><a id="more"></a><h3 id="多线程基础"><a href="#多线程基础" class="headerlink" title="多线程基础"></a>多线程基础</h3><h4 id="一、程序，进程，线程"><a href="#一、程序，进程，线程" class="headerlink" title="一、程序，进程，线程"></a>一、程序，进程，线程</h4><ul><li><strong>程序：</strong> 一组指令的有序集合，是静态的实体。</li><li><strong>进程：</strong> 系统进行资源分配的基本单位，是程序在某个数据集上的执行，进程 = 程序 + 数据集 + 进程控制块。</li><li><strong>线程：</strong> 系统进行调度的最小单位，共享进程的资源，是程序中一个单一的控制流程，在单个程序中同时运行多个线程完成不同的工作，称为多线程。</li></ul><hr><h4 id="二、线程状态"><a href="#二、线程状态" class="headerlink" title="二、线程状态"></a>二、线程状态</h4><ul><li><strong>初始状态(NEW)：</strong> 当线程创建后，但还没有调用start()方法。</li><li><strong>运行状态(RUNNABLE)：</strong>java线程中将就绪(ready)和运行中(running)这两种状态统称为“运行”。当线程对象创建后，其他线程调用该对象的start()方法,改线程处于可以运行线程池中，等待cpu随机调度。</li><li><strong>阻塞状态(BLOCKED)：</strong>线程阻塞于锁。</li><li><strong>等待(WAITING)：</strong>进入该状态的线程正在等待另一个线程执行特定动作（通知或中断）</li><li><strong>超时等待(TIMED_WAITING)：</strong>该状态不同于WAITING，它可以在指定的时间后自行返回。</li><li><strong>终止(TERMINATED)：</strong>表示该线程已经执行完毕。</li></ul><p><img src="E:%5CimageForBolg%5CThreadState.jpg" srcset="/img/loading.gif" alt="ThreadState"></p><hr><h4 id="三、创建多线程"><a href="#三、创建多线程" class="headerlink" title="三、创建多线程"></a>三、创建多线程</h4><h5 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h5><p><strong>重写run()方法：</strong> 如果继承了Thread类，那么就不能继承其他的类。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;                                                                                                                                   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(String name)</span></span>&#123;<span class="hljs-keyword">super</span>(name);<span class="hljs-comment">//重写构造，可以对线程添加名字</span>&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)&#123;System.out.println(Thread.currentThread().getName());            <span class="hljs-comment">//输出当前线程的名字</span>&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        MyThread mt = <span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">"test"</span>);        System.out.println(Thread.currentThread().getName());        <span class="hljs-comment">//输出当前线程的名字 --- main</span>        mt.start();            &#125;&#125;</code></pre><hr><h5 id="实现Runable接口"><a href="#实现Runable接口" class="headerlink" title="实现Runable接口"></a>实现Runable接口</h5><p><strong>实现run方法：</strong> 解决继承Thread的缺点，没有返回值.</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RunableTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            System.out.println(<span class="hljs-string">"good time"</span>);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        RunableTest runableTest1 = <span class="hljs-keyword">new</span> RunableTest();        RunableTest runableTest2 = <span class="hljs-keyword">new</span> RunableTest();        <span class="hljs-keyword">new</span> Thread(runableTest1).start();        <span class="hljs-keyword">new</span> Thread(runableTest1).start();        <span class="hljs-keyword">new</span> Thread(runableTest2).start();    &#125;&#125;</code></pre><h5 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h5><p><strong>实现run方法：</strong> </p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello world"</span>;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        FutureTask&lt;String&gt; futureTask = <span class="hljs-keyword">new</span> FutureTask&lt;String&gt;(<span class="hljs-keyword">new</span> CallTest());        <span class="hljs-keyword">new</span> Thread(futureTask).start();        <span class="hljs-keyword">try</span> &#123;            String result = futureTask.get();            System.out.println(result);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><hr><h3 id="Thread类方法"><a href="#Thread类方法" class="headerlink" title="Thread类方法"></a>Thread类方法</h3><h5 id="currentThread-方法"><a href="#currentThread-方法" class="headerlink" title="currentThread()方法"></a>currentThread()方法</h5><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> Thread <span class="hljs-title">currentThread</span><span class="hljs-params">()</span></span>;</code></pre><p>currentThread()方法可返回代码段正在被哪个线程调用的信息。</p><h5 id="isAlive-方法"><a href="#isAlive-方法" class="headerlink" title="isAlive()方法"></a>isAlive()方法</h5><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAlive</span><span class="hljs-params">()</span></span>;</code></pre><p>方法isAlive()的功能是判断当前的线程是否处于活动(除开TERMINATED)状态。</p><h5 id="join-方法"><a href="#join-方法" class="headerlink" title="join()方法"></a>join()方法</h5><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-keyword">long</span> millis)</span></span>;</code></pre><p>调用线程对象的join()方法后,当前线程从RUNNABLE切换到WAITING/TIMED_WAITING状态，直到线程对象的run执行完毕。</p><h5 id="sleep-方法"><a href="#sleep-方法" class="headerlink" title="sleep()方法"></a>sleep()方法</h5><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-keyword">long</span> millis)</span></span>;</code></pre><p>sleep()方法会释放cpu的时间片，但是不会释放锁，调用sleep()之后从RUNNABLE状态转为TIMED_WAITING状态</p><h5 id="yield-方法"><a href="#yield-方法" class="headerlink" title="yield()方法"></a>yield()方法</h5><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">yield</span><span class="hljs-params">()</span></span>;</code></pre><p>提示线程调度器当前线程愿意放弃当前CPU的使用。如果当前资源不紧张，调度器可以忽略这个提示。本质上线程状态一直是RUNNABLE,但是我可以理解为RUNNABLE到RUNNING的转换</p><hr><h3 id="线程优先级和守护线程"><a href="#线程优先级和守护线程" class="headerlink" title="线程优先级和守护线程"></a>线程优先级和守护线程</h3><h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><p>java中的线程优先级的范围是1～10，默认的优先级是5。每个线程默认的优先级都与创建它的父线程具有相同的优先级。默认情况下，mian线程具有普通优先级。“高优先级线程”会优先于“低优先级线程”执行。”高优先级线程”可能会优先于“低优先级线程”执行，Thread提供了<code>setPriority()</code>和<code>getPriority()</code>方法来设置和返回线程优先级。</p><p> Thread类有3个静态常量： </p><pre><code class="hljs ini"><span class="hljs-attr">MAX_PRIORITY</span> = <span class="hljs-number">10</span><span class="hljs-attr">MIN_PRIORITY</span> = <span class="hljs-number">1</span><span class="hljs-attr">NORM_PRIORITY</span> = <span class="hljs-number">5</span></code></pre><hr><h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><ul><li><p>java 中有两种线程：用户线程和守护线程。可以通过<code>isDaemon()</code>方法来区别它们：如果返回false，则说明该线程是“用户线程”；否则就是“守护线程”。用户线程一般用户执行用户级任务，而守护线程也就是“后台线程”，一般用来执行后台任务，垃圾回收线程，就是最典型的守护线程。</p></li><li><p>所有的用户线程结束后，守护线程才会随之结束。</p></li><li><p>main线程是用户线程，main线程结束后，不会影响到其他用户线程。</p></li><li><p><code>setDaemon(true)</code>必须在调用线程的start()方法之前设置，否则会抛IllegalThreadStateException异常。</p></li><li><p>在守护线程中产生的新线程也是守护线程。 </p></li></ul><hr><h3 id="线程同步与线程安全"><a href="#线程同步与线程安全" class="headerlink" title="线程同步与线程安全"></a>线程同步与线程安全</h3><h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>CPU可能随机的在多个处于就绪状态中的线程中进行切换，就意味者一个线程并不是被执行完所有的语句之后才被切换的，所以多线程环境下对共享资源的访问可能会引起此共享资源的不一致性，这就是线程安全问题。为避免线程安全问题，应该避免多线程环境下对共享资源的并发访问。</p><hr><h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><p>java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（如数据的增删改查），将会导致数据不准确，相互之间产生冲突，因此加入同步机制以避免在该线程没有完成操作之前，被其他线程的调用，从而保证了该变量的唯一性和准确性。</p><h5 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h5><p>对共享资源进行访问的方法定义中加上synchronized关键字修饰，使得此方法称为同步方法。可以简单理解成对此方法进行了加锁，其锁对象为当前方法所在的对象自身。多线程环境下，当执行此方法时，首先都要获得此同步锁（且同时最多只有一个线程能够获得），只有当线程执行完此同步方法后，才会释放锁对象，其他的线程才有可能获取此同步锁，以此类推…。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;         <span class="hljs-comment">// ....</span>&#125;</code></pre><h5 id="同步块"><a href="#同步块" class="headerlink" title="同步块"></a>同步块</h5><p>解决线程安全问题其实只需限制对共享资源访问的不确定性即可。使用同步方法时，使得整个方法体都成为了同步执行状态，会使得可能出现同步范围过大的情况，于是，针对需要同步的代码可以直接另一种同步方式——同步代码块来解决。</p><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (obj) &#123;     <span class="hljs-comment">//...</span>&#125;</code></pre><p>其中，obj为锁对象，因此，选择哪一个对象作为锁是至关重要的。一般情况下，都是选择此共享资源对象作为锁对象。</p><h5 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h5><p><strong>原理：</strong><br>在java中，每一个对象有且仅有一个同步锁。这也意味着，同步锁是依赖于对象而存在。当前线程调用某对象的synchronized方法时，就获取了该对象的同步锁。例如，synchronized(obj)，当前线程就获取了“obj这个对象”的同步锁。不同线程对同步锁的访问是互斥的。也就是说，某时间点，对象的同步锁只能被一个线程获取到。</p><hr><h4 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h4><p><strong>wait() / notify() / notifyAll()</strong> ：都是Object类的方法。</p><ul><li><p>wait()：导致当前线程等待并使其进入到等待阻塞状态。直到其他线程调用该同步锁对象的notify()或notifyAll()方法来唤醒此线程。</p></li><li><p>notify()：唤醒在此同步锁对象上等待的单个线程，如果有多个线程都在此同步锁对象上等待，则会任意选择其中某个线程进行唤醒操作，只有当前线程放弃对同步锁对象的锁定，才可能执行被唤醒的线程。</p></li><li><p>notifyAll()：唤醒在此同步锁对象上等待的所有线程，只有当前线程放弃对同步锁对象的锁定，才可能执行被唤醒的线程。</p></li></ul><p>1.<code>wait()</code>方法执行后，当前线程立即进入到等待阻塞状态，其后面的代码不会执行； </p><p>2.<code>notify()</code>/<code>notifyAll()</code>方法执行后，将唤醒此同步锁对象上的（任意一个-<code>notify()</code>/所有-<code>notifyAll()</code>）线程对象，但是，此时还并没有释放同步锁对象，也就是说，如果<code>notify()</code>/<code>notifyAll()</code>后面还有代码，还会继续执行，直到当前线程执行完毕才会释放同步锁对象；</p><p>3.<code>notify()</code>/<code>notifyAll()</code>执行后，如果下面有<code>sleep()</code>方法，则会使当前线程进入到阻塞状态，但是同步对象锁没有释放，依然自己保留，那么一定时候后还是会继续执行此线程，接下来同2；</p><p>4.<code>wait()</code>/<code>notify()</code>/<code>nitifyAll()</code>完成线程间的通信或协作都是基于相同对象锁的，因此，如果是不同的同步对象锁将失去意义，同时，同步对象锁最好是与共享资源对象保持一一对应关系；</p><p>5.当wait线程唤醒后并执行时，是接着上次执行到的<code>wait()</code>方法代码后面继续往下执行的。</p>]]></content>
      
      
      <categories>
          
          <category> 初学Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初学Java-网络编程</title>
      <link href="/2019/12/16/%E5%88%9D%E5%AD%A6Java-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2019/12/16/%E5%88%9D%E5%AD%A6Java-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>网络编程总结</p><a id="more"></a><h3 id="TCP-与-UDP-协议"><a href="#TCP-与-UDP-协议" class="headerlink" title="TCP 与 UDP 协议"></a>TCP 与 UDP 协议</h3><ul><li>TCP：<br>提供面向连接的服务，在传输数据之前必须先建立连接，数据传输之后要释放连接。流模式。</li><li>UDP：<br>在传输数据之前不建立连接，直接发送数据报到网络。数据报模式。<h3 id="套字节与端口"><a href="#套字节与端口" class="headerlink" title="套字节与端口"></a>套字节与端口</h3></li><li>套接字：<br>当两台计算机连接起来建立一个双向的通信链路时，这个双向通信链路的每一端称之为一个套接字（Socket）。</li><li>端口:<br>一台服务器上可能提供多种服务，使用 IP 地址只能唯一定位到某一台计算机，却不能准确地连接到想要连接的服务器。通常使用一个 0~65535 的整数来标识该机器上的某个服务，这个整数就是端口号（Port）。<h3 id="Java-InetAddress-类"><a href="#Java-InetAddress-类" class="headerlink" title="Java InetAddress 类"></a>Java InetAddress 类</h3>Internet 上的主机有两种方式表示地址，分别为域名和 IP 地址。java.net 包中的 InetAddress 类对象包含一个主机地址的域名和 IP 地址。 </li></ul><p><strong>InetAddress类的常用方法 ：</strong></p><ul><li>static InetAddress[] getAHByName(String host)<br>在给定主机名的情况下，根据系统上配置的名称，服务器返回其 IP 地址所组成的数组</li><li>static InetAddress getByAddress(String host)<br>在给定主机名的情况下确定主机的 IP 地址</li><li>String getHostAddress()<br>返回 IP 地址字符串（以文本表现形式）</li><li>String getHostName()<br>返回此 IP 地址的主机名</li><li>static InetAdderss getLocalHost()<br>返回本地主机</li></ul><h3 id="Java-TCP通信"><a href="#Java-TCP通信" class="headerlink" title="Java TCP通信"></a>Java TCP通信</h3><p>TCP 网络程序是指利用 Socket 编写的通信程序。利用 TCP 协议进行通信的两个应用程序是有主次之分的，一个是服务器程序，一个是客户端程序，两者的功能和编写方法不太一样。其中 ServerSocket 类表示 Socket 服务器端，Socket 类表示 Socket 客户端。Socket 类表示 Socket 客户端，两者之间的交互过程如下：</p><ol><li>服务器端创建一个 ServerSocket （服务器端套接字），调用 accept() 方法等待客户端来连接。</li><li>客户端程序创建一个 Socket，请求与服务器建立连接。</li><li>服务器接收客户端的连接请求，同时创建一个新的 Socket 与客户端建立连接，服务器继续等待新的请求。</li></ol><h4 id="ServerSocket-类"><a href="#ServerSocket-类" class="headerlink" title="ServerSocket 类"></a>ServerSocket 类</h4><p>ServerSocket 类是与 Socket 类相对应的用于表示通信双方中的服务器端，用于在服务器上开一个端口，被动的等待数据（使用accept() 方法）并建立连接进行数据交互。<br>服务器套接字一次可与一个套接字连接，如果多台客户端同时提出连接请求，服务器套接字会将请求连接的客户端存入队列中，然后从中取出一个套接字与服务器新建的套接字连接起来，若请求连接大于最大容纳数，则多出的连接请求被拒绝；默认的队列大小是50。</p><p><strong>ServerSocket 类常用方法：</strong></p><ul><li>Server accept()：监听要连接到此套接字并接受它。 </li><li>void close()：关闭此套接字。</li></ul><p>调用 accept() 方法会返回一个和客户端 Socket 对象相连接的 Socket 对象</p><p>** 使用 ServerSocket 类创建一个使用端口 8888 的服务器端套接字，如下：**</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">//在8888端口创建一个服务器端套接字</span>        ServerSocket s_socket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8888</span>);        System.out.println(<span class="hljs-string">"服务器端 Socket 套接字创建成功！"</span>);        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;             System.out.println(<span class="hljs-string">"等待客户端的连接请求!"</span>);            <span class="hljs-comment">//等待客户端的连接请求</span>            Socket socket = s_socket.accept();             <span class="hljs-comment">//阻塞式创建连接</span>            <span class="hljs-comment">//如果没有客户端的连接请求，则 accept() 方法为空，</span>            <span class="hljs-comment">//所以不会输出“成功建立与客户端的连接”</span>            System.out.println(<span class="hljs-string">"成功建立与客户端的连接!"</span>);                        <span class="hljs-comment">//从客户端接收数据</span>            <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];        in = socket.getInputStream();        <span class="hljs-keyword">int</span> len = in.read(b);                        <span class="hljs-comment">//将数据发送到客户端</span>            out = socket.getOutputStream();<span class="hljs-comment">//发送数据</span>            out.write(<span class="hljs-string">"欢迎登陆到客户端！"</span>.getBytes());                    &#125;    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre><h4 id="Socket-类"><a href="#Socket-类" class="headerlink" title="Socket 类"></a>Socket 类</h4><p>Socket 类表示通信双方中的客户端，用于呼叫远端机器上的一个端口，主动向服务器端发送数据（当连接建立后也能接收数据）</p><p><strong>Socket类构造方法</strong></p><ul><li>Socket(InetAddress address,int port)：<br>创建一个流套接字并将其连接到指定 IP 地址的指定端口。</li></ul><p><strong>Socket 类常用方法：</strong></p><ul><li>void close()：<br>关闭此套接字。</li><li>InputStream getInputStream()：<br>返回此套接字的输入流。</li><li>OutputStream getOutputStream()：<br>返回此套接字的输出流。</li></ul><p><strong>使用Socket类创建客户端套接字，和服务器端完成简单的通信：</strong></p><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//1.定义 Socket 对象、OutputStream 对象和一个 InputStream 对象并完成初始化</span>        Socket socket = <span class="hljs-keyword">null</span>;        OutputStream out = <span class="hljs-keyword">null</span>;        InputStream in = <span class="hljs-keyword">null</span>;        <span class="hljs-comment">//定义服务器端的 IP 地址和端口号</span>        String serverIP = <span class="hljs-string">"127.0.0.1"</span>;<span class="hljs-comment">//服务器端 IP 地址</span>        <span class="hljs-keyword">int</span> port = <span class="hljs-number">8888</span>;<span class="hljs-comment">//服务器端端口号</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//2.建立与服务器端的连接并将数据发送到服务器端</span>            socket = <span class="hljs-keyword">new</span> Socket(serverIP, port);<span class="hljs-comment">//建立连接</span>            out = socket.getOutputStream();<span class="hljs-comment">//发送数据</span>            out.write(<span class="hljs-string">"我是客户端数据"</span>.getBytes());             <span class="hljs-comment">//3.从输入流中读出服务器的反馈信息并输出到控制台</span>            <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];            in = socket.getInputStream();            <span class="hljs-keyword">int</span> len = in.read(b);            System.out.println(<span class="hljs-string">"服务器端的反馈为："</span> + <span class="hljs-keyword">new</span> String(b, <span class="hljs-number">0</span>, len));        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">//4.关闭流及 Socket 对象</span>            <span class="hljs-keyword">try</span> &#123;                in.close();                out.close();                socket.close();            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</code></pre><h3 id="Java-UDP通信"><a href="#Java-UDP通信" class="headerlink" title="Java UDP通信"></a>Java UDP通信</h3><p>虽然 UDP 协议是一种不太可靠的协议，但有时在需要较快地接收数据并且可以忍受较小错误的情况下，UDP就会表现出更大的优势。</p><p><strong>使用 UDP 协议发送数据的步骤：</strong></p><ul><li>使用 DatagramSocket() 创建一个数据包套接字。</li><li>使用 DatagramPacket() 创建要发送的数据包。</li><li>使用 DatagramSocket 类的 send() 方法发送数据包。</li></ul><p><strong>接收 UDP 数据包的步骤：</strong></p><ul><li>使用 DatagramSocket 创建数据包套接字，并将其绑定到指定的端口。</li><li>使用 DatagramPacket 创建字节数组来接收数据包。</li><li>使用 DatagramPacket 类的 receive() 方法接收 UDP 包</li></ul><h4 id="DatagramPacket类"><a href="#DatagramPacket类" class="headerlink" title="DatagramPacket类"></a>DatagramPacket类</h4><p>DatagramPacket 类用来表示数据报包，数据报包用来实现无连接包投递服务。每条报文仅根据该包中包含的信息从一台机器路由到另一台机器。从一台机器发送到另一台机器的多个包可能选择不同的路由，也可能按不同的顺序到达。</p><h4 id="DatagramSocket-类"><a href="#DatagramSocket-类" class="headerlink" title="DatagramSocket 类"></a>DatagramSocket 类</h4><p>DatagramSocket 类用于表示发送和接收数据报包的套接字。数据报包套接字是包投递服务的发送或接收点。每个在数据报包套接字上发送或接收的包都是单独编址和路由的。</p><p><strong>UDP通信客户端/服务端：</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<span class="hljs-comment">//1.使用DatagramSocket 指定端口 创建接收端/服务端  端口号不能相同</span>DatagramSocket socket = <span class="hljs-keyword">new</span> DatagramSocket(<span class="hljs-number">8888</span>); <span class="hljs-comment">//  2.准备数据，接收方的地址(ip,端口)</span>    SocketAddress address = <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">"localhost"</span>,<span class="hljs-number">9999</span>);    <span class="hljs-keyword">byte</span>[] datas = <span class="hljs-string">"发送数据****"</span>.getBytes();<span class="hljs-comment">//3.封装成DatagramPacekt包裹，需要指定目的地 </span>DatagramPacket packet = <span class="hljs-keyword">new</span> DatagramPacket(datas,<span class="hljs-number">0</span>,datas.length,address);     <span class="hljs-comment">//  4.发送数据包</span>    socket.send(packet);        <span class="hljs-comment">//  5.准备空间接收数据包(数据包最大60K)</span>    <span class="hljs-keyword">byte</span>[] container = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">60</span>];    <span class="hljs-comment">//  6.构造 DatagramPacket，用来接收长度为 length 的数据包</span>DatagramPacket packet = <span class="hljs-keyword">new</span> DatagramPacket(container,container.length);<span class="hljs-comment">// * 5.阻塞式接收包裹receive(DatagramPacekt)</span>server.receive(packet);        <span class="hljs-comment">//关闭 DatagramSocket 对象</span>    server.colse();&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 初学Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初学java-IO</title>
      <link href="/2019/12/13/%E5%88%9D%E5%AD%A6java-IO/"/>
      <url>/2019/12/13/%E5%88%9D%E5%AD%A6java-IO/</url>
      
        <content type="html"><![CDATA[<p>特地对java的IO做一个总结</p><a id="more"></a><h2 id="IO概述"><a href="#IO概述" class="headerlink" title="IO概述"></a>IO概述</h2><ul><li>IO中最重要的5个类和1个接口：<strong>File、OutputStream、InputStream、Writer、Reader；Serializable.</strong></li></ul><h2 id="io体系"><a href="#io体系" class="headerlink" title="io体系"></a>io体系</h2><p>从操作方向(<strong>代码的角度</strong>)来看，IO类可以分为：</p><ul><li>输入流：读取/输入数据 到代码</li><li>输出流：把代码的数据 写出/输出</li></ul><hr><p>从操作类型来看，IO类可以分为：</p><ul><li>字节流 : 字节流可以操作任何数据(文本，图片，视频)，因为所有的数据都是以字节的形式存储。</li><li>字符流 : 字符流只能操作字符数据。</li></ul><p><em>Q: 字符在计算机中是怎么表示的？</em><br><em>A：将字符是按照规则翻译对应的二进制数(编码)，一个字符通常用多个字节存储。</em></p><p><em>Q: 字节流可以操作字符数据吗？</em><br><em>A：”字节流可以操作任何数据 “，是可以操作的，但是。。。</em></p><p><em>Q: 字节流可以操作任何数据，为什么还需要字符流？</em><br><em>A：字节流处理文本文件会出现乱码问题(字节流不编码&amp;解码)，所以需要字符流来处理文本文件。</em></p><p><em>Q：那我就是想用字节流处理文本文件，咋办呢？</em><br><em>A：你自己用代码去编码，解码就可以了。</em></p><p><em>Q：那既然有字符流，为啥没有图片流，音频流，视频流？</em><br><em>A：emmm,我等下去问问老师。</em></p><p><em>Q：那什么时候用字符流，什么时候用字节流啊？</em><br><em>A：处理文本文件用字符流，其他的用字节流。</em></p><hr><p>从操作对象来看，IO类可以分为：</p><ul><li><p>文件(节点流)：对文件进行读取、写入操作。</p><pre><code class="hljs java">FileInputStream, FileOutputStreamFileWriter, FileReader</code></pre></li><li><p>数组(节点流)：对数组进行读取、写入操作。</p><pre><code class="hljs java">ByteArrayInputStream, ByteArrayOutputStreamCharArrayReader, CharArrayWriter</code></pre></li><li><p>管道操作(节点流)：实现管道的输入和输出（线程间通信）。</p><pre><code class="hljs java">PipedInputStream, PipedOutputStreamPipedReader, PipedWriter</code></pre></li><li><p>缓冲操作(处理流)：在读入或写出时，对数据进行缓存，以减少I/O的次数。</p><pre><code class="hljs java">BufferedInputStream, BufferedOutputStreamBufferedReader, BufferedWriter</code></pre></li><li><p>字节转换字符(处理流)：按照一定的编码/解码标准将字节流转换为字符流。</p><pre><code class="hljs java">InputStreamReader、OutputStreWriter</code></pre></li><li><p>打印(处理流)：包含方便的打印方法 。</p><pre><code class="hljs java">PrintStream、PrintWriter</code></pre></li><li><p>基本数据类型(处理流)：允许应用程序以与机器无关方式从底层输入流中读写基本 Java 数据类型。</p><pre><code class="hljs java">DataInputStream、DataOutputStream</code></pre></li><li><p>对象序列化反序列化(处理流)：保存在内存中的各种对象的状态。</p><pre><code class="hljs java">ObjectInputStream、ObjectOutputStream</code></pre></li></ul><p><strong>节点流：程序用于直接操作目标设备所对应的类</strong><br><strong>处理流：程序通过一个间接流类去调用节点流类，以达到更加灵活方便地读写各种类型的数据</strong><br><strong>节点流是一杯原味咖啡的话，处理流就是各种配料，让节点流更好喝</strong></p><p><em>Q：处理流要怎么使用呢？</em><br><em>A：实例化处理流类的时候要给一个节点流对象，</em></p><pre><code class="hljs java">BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader());InputStreamReader isr = <span class="hljs-keyword">new</span> InputStreamReader(<span class="hljs-keyword">new</span> FileInputStream());</code></pre><p><em>Q：为什么不直接操作数组，而用内存数组流呢？</em><br><em>A：数组是基本数据类型，而内存数组流是类，就和有<code>int</code>但是还有Integer类是一样的。</em></p><p><em>Q：管道是啥啊？</em><br><em>A：emmm,我也不懂，等我学会了再告诉你……</em></p><p><em>Q：什么情况下用缓存流啊？</em><br><em>A：缓存流可以优化性能，看到文件流和数组流就套上去。但是没必要套几个缓存流，一个就够了。</em></p><pre><code class="hljs java">BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader());</code></pre><p><em>Q：什么情况下用字节转换字符流啊？</em><br><em>A：<code>FileReader</code>和 <code>FileWriter</code>的<strong>字符编码</strong>是IDEA的设置，要使用别的<strong>字符编码</strong>，就用字节转换字节流。</em></p><pre><code class="hljs java">InputStreamReader isr = <span class="hljs-keyword">new</span> InputStreamReader(<span class="hljs-keyword">new</span> FileInputStream(),<span class="hljs-string">"GBK"</span>);</code></pre><p><em>Q：打印流可以用来辅助输入流吗？</em><br><em>A：不可以，打印流只能为其他输出流添加功能。所以打印流永远不会抛出IO异常。</em></p><p><em>Q：<code>PrintStream</code>和 <code>PrintWriter</code>有么区别啊？</em><br><em>A：<code>PrintStream</code>和 <code>PrintWriter</code>中的方法是一样的，但是 <code>PrintWriter</code>的构造方法比 <code>PrintStream</code>多了一个接收 字符流 的构成方法( <code>PrintWriter</code>比 <code>PrintStream</code>灵活)，所以掌握 <code>PrintWriter</code>就可以了</em></p><p><em>Q：基本数据类型流是的功能好像不是很有用唉！</em><br><em>A：有用的很！用 <code>FileOutputStream</code>写入一个<code>int</code>类型的数据到文件，只会写入最低位，。而用 <code>DataOutputStream</code>就能避免这样的情况。</em></p><p><em>Q：那使用基本数据类型流有什么要注意的？</em><br><em>A：读取数据的顺序一定要和写入的顺序一致。</em></p><p><em>Q：所以的对象都可以通过序列化保持下来吗？</em><br><em>A：只要该类实现了 <code>java.io.Serializable</code>接口，都可以序列化或者反序列化。如果有属性不需要序列化，可以用 <code>transient</code>关键字修饰。</em></p><hr>]]></content>
      
      
      <categories>
          
          <category> 初学Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown命令</title>
      <link href="/2019/11/17/%E5%B8%B8%E7%94%A8Markd%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/11/17/%E5%B8%B8%E7%94%A8Markd%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>记录一些常用的Markdown语法。</p><a id="more"></a><h2 id="mermaid"><a href="#mermaid" class="headerlink" title="mermaid"></a>mermaid</h2><p>语法框架：</p><pre><code class="hljs apl">```mermaid    ……流程图代码……```</code></pre><hr><p>起始代码：<br>graph &lt;布局方向&gt;</p><pre><code class="hljs apl">graph TB    ...    ...</code></pre><p>TB（Top Bottom）表示从上向下布局<br>BT（Bottom Top）表示从下向下布局<br>LR（Left Right）表示从左向右布局<br>RL（Right Left）表示从右向左布局</p>]]></content>
      
      
      
        <tags>
            
            <tag> 常用命令 </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo命令</title>
      <link href="/2019/11/17/Hexo%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/11/17/Hexo%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>记录一些常用的Hexo命令。</p><a id="more"></a><h3 id="hexo-s"><a href="#hexo-s" class="headerlink" title="hexo s"></a>hexo s</h3><p><code>hexo s</code></p><ul><li>启动本地服务器，用于预览主题。默认地址： <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></li><li>hexo s 是 hexo server 的缩写，命令效果一致；</li><li>预览的同时可以修改文章内容或主题代码，保存后刷新页面即可；</li><li>对 Hexo 根目录 _config.yml 的修改，需要重启本地服务器后才能预览效果。</li></ul><hr><h3 id="hexo-new"><a href="#hexo-new" class="headerlink" title="hexo new"></a>hexo new</h3><p><code>hexo new &quot;常用hexo语法 一&quot;</code></p><ul><li>新建一篇标题为 常用hexo命令 一 的文章，因为标题里有空格，所以加上了引号。</li><li>文章标题可以在对应 md 文件里改，新建时标题可以写的简单些。</li></ul><hr><h3 id="hexo-new-page"><a href="#hexo-new-page" class="headerlink" title="hexo new page"></a>hexo new page</h3><p><code>hexo new page aboutme</code></p><ul><li>新建一个标题为 aboutme 的页面，默认链接地址为 主页地址/aboutme/</li><li>标题可以为中文，但一般习惯用英文；</li><li>页面标题和文章一样可以随意修改；</li><li>页面不会出现在首页文章列表和归档中，也不支持设置分类和标签。</li></ul><hr><h3 id="hexo-clean"><a href="#hexo-clean" class="headerlink" title="hexo clean"></a>hexo clean</h3><p><code>hexo clean</code></p><ul><li>清除缓存文件 db.json 和已生成的静态文件 public 。</li><li>网站显示异常时可以执行这条命令试试。</li></ul><hr><h3 id="hexo-g"><a href="#hexo-g" class="headerlink" title="hexo g"></a>hexo g</h3><p><code>hexo g</code></p><ul><li>生成网站静态文件到默认设置的 public 文件夹。</li><li>便于查看网站生成的静态文件或者手动部署网站；</li><li>如果使用自动部署，不需要先执行该命令；</li><li>hexo g 是 hexo generate 的缩写，命令效果一致。</li></ul><hr><h3 id="hexo-d"><a href="#hexo-d" class="headerlink" title="hexo d"></a>hexo d</h3><p><code>hexo d</code></p><ul><li><p>自动生成网站静态文件，并部署到设定的仓库。</p></li><li><p>hexo d 是 hexo deploy 的缩写，命令效果一致。</p></li></ul><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 常用命令 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
