<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>GOF32-工厂模式</title>
      <link href="/2020/01/15/GOF32-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/01/15/GOF32-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>GOF32-工厂模式</p><a id="more"></a><h3 id="面向对象设计的基本原则："><a href="#面向对象设计的基本原则：" class="headerlink" title="面向对象设计的基本原则："></a>面向对象设计的基本原则：</h3><ul><li>OCP（开闭原则，Open-Closed Principle）：一个软件的实体应当对扩展开放，对修改关闭。</li><li>DIP（依赖倒转原则，Dependence Inversion Principle）：要针对接口编程，不要针对实现编程。</li><li>LoD（迪米特法则，Law of Demeter）：只与你直接的朋友通信，而避免和陌生人通信。<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3>实现了创建者和调用者的分离<br>有简单工厂，工厂方法，抽象工厂</li></ul><h4 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Audi</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"我是奥迪！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Byd</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"我是比亚迪！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">createCar</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">"奥迪"</span>.equals(type)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Audi();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"比亚迪"</span>.equals(type)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Byd();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client02</span> </span>&#123; <span class="comment">// 调用者</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">CarFactory.createCar(<span class="string">"奥迪"</span>).run();</span><br><span class="line">CarFactory.createCar(<span class="string">"比亚迪"</span>).run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Audi</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"我是奥迪！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Byd</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"我是比亚迪！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Car <span class="title">createCar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AudiFactory</span> <span class="keyword">implements</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Car <span class="title">createCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Audi();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BydFactory</span> <span class="keyword">implements</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Car <span class="title">createCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Byd();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> AudiFactory().createCar().run();</span><br><span class="line"><span class="keyword">new</span> BydFactory().createCar().run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Engine</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LuxuryEngine</span> <span class="keyword">implements</span> <span class="title">Engine</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"转的快！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"启动快!可以自动启停！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LowEngine</span> <span class="keyword">implements</span> <span class="title">Engine</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"转的慢！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"启动慢!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Seat</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">massage</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LuxurySeat</span> <span class="keyword">implements</span> <span class="title">Seat</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">massage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"可以自动按摩！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LowSeat</span> <span class="keyword">implements</span> <span class="title">Seat</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">massage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"不能按摩！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Tyre</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">revolve</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LuxuryTyre</span> <span class="keyword">implements</span> <span class="title">Tyre</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">revolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"旋转不磨损！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LowTyre</span> <span class="keyword">implements</span> <span class="title">Tyre</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">revolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"旋转磨损快！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line"><span class="function">Engine <span class="title">createEngine</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Seat <span class="title">createSeat</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Tyre <span class="title">createTyre</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LuxuryCarFactory</span> <span class="keyword">implements</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Engine <span class="title">createEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> LuxuryEngine();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Seat <span class="title">createSeat</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> LuxurySeat();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Tyre <span class="title">createTyre</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> LuxuryTyre();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LowCarFactory</span> <span class="keyword">implements</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Engine <span class="title">createEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> LowEngine();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Seat <span class="title">createSeat</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> LowSeat();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Tyre <span class="title">createTyre</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> LowTyre();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">CarFactory factory = <span class="keyword">new</span> LuxuryCarFactory();</span><br><span class="line">Engine engine = factory.createEngine();</span><br><span class="line">Seat seat = factory.createSeat();</span><br><span class="line">Tyre tyre = factory.createTyre();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>简单工厂模式：虽然某种程度不符合设计原则，但实际使用最多</li><li>工厂方法模式：不修改已有类的前提下，通过增加新的工厂类实现扩展。</li><li>抽象工厂模式：不可以增加产品，可以增加产品族</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>JDK 中 Calendar 的 getInstance 方法</li><li>JDBC 中 Connection 对象的获取</li><li>Hibernate 中 SessionFactory 创建 Session</li><li>Spring 中 IOC 容器创建管理 bean对象</li><li>XML 解析时的 DocumentBuilderFactory 创建解析器对象</li><li>反射中 Class 对象的 newInstance()</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> GOF32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初学Java-多线程</title>
      <link href="/2019/12/16/%E5%88%9D%E5%AD%A6Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2019/12/16/%E5%88%9D%E5%AD%A6Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>看完 <a href="https://www.cnblogs.com/xiaoxi/" target="_blank" rel="noopener">平凡希</a> 大佬的<a href="https://www.cnblogs.com/xiaoxi/p/7581899.html" target="_blank" rel="noopener">《java多线程基础总结》</a> ，结合总结的所学，写出的一篇关于java多线程基础的文章</p><a id="more"></a><h3 id="多线程基础"><a href="#多线程基础" class="headerlink" title="多线程基础"></a>多线程基础</h3><h4 id="一、程序，进程，线程"><a href="#一、程序，进程，线程" class="headerlink" title="一、程序，进程，线程"></a>一、程序，进程，线程</h4><ul><li><strong>程序：</strong> 一组指令的有序集合，是静态的实体。</li><li><strong>进程：</strong> 系统进行资源分配的基本单位，是程序在某个数据集上的执行，进程 = 程序 + 数据集 + 进程控制块。</li><li><strong>线程：</strong> 系统进行调度的最小单位，共享进程的资源，是程序中一个单一的控制流程，在单个程序中同时运行多个线程完成不同的工作，称为多线程。</li></ul><hr><h4 id="二、线程状态"><a href="#二、线程状态" class="headerlink" title="二、线程状态"></a>二、线程状态</h4><ul><li><strong>初始状态(NEW)：</strong> 当线程创建后，但还没有调用start()方法。</li><li><strong>运行状态(RUNNABLE)：</strong>java线程中将就绪(ready)和运行中(running)这两种状态统称为“运行”。当线程对象创建后，其他线程调用该对象的start()方法,改线程处于可以运行线程池中，等待cpu随机调度。</li><li><strong>阻塞状态(BLOCKED)：</strong>线程阻塞于锁。</li><li><strong>等待(WAITING)：</strong>进入该状态的线程正在等待另一个线程执行特定动作（通知或中断）</li><li><strong>超时等待(TIMED_WAITING)：</strong>该状态不同于WAITING，它可以在指定的时间后自行返回。</li><li><strong>终止(TERMINATED)：</strong>表示该线程已经执行完毕。</li></ul><p><img src="E:%5CimageForBolg%5CThreadState.jpg" alt="ThreadState"></p><hr><h4 id="三、创建多线程"><a href="#三、创建多线程" class="headerlink" title="三、创建多线程"></a>三、创建多线程</h4><h5 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h5><p><strong>重写run()方法：</strong> 如果继承了Thread类，那么就不能继承其他的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>(name);<span class="comment">//重写构造，可以对线程添加名字</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName());</span><br><span class="line">            <span class="comment">//输出当前线程的名字</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyThread mt = <span class="keyword">new</span> MyThread(<span class="string">"test"</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        <span class="comment">//输出当前线程的名字 --- main</span></span><br><span class="line">        mt.start();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="实现Runable接口"><a href="#实现Runable接口" class="headerlink" title="实现Runable接口"></a>实现Runable接口</h5><p><strong>实现run方法：</strong> 解决继承Thread的缺点，没有返回值.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunableTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"good time"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RunableTest runableTest1 = <span class="keyword">new</span> RunableTest();</span><br><span class="line">        RunableTest runableTest2 = <span class="keyword">new</span> RunableTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(runableTest1).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(runableTest1).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(runableTest2).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h5><p><strong>实现run方法：</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallTest</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;String&gt;(<span class="keyword">new</span> CallTest());</span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String result = futureTask.get();</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Thread类方法"><a href="#Thread类方法" class="headerlink" title="Thread类方法"></a>Thread类方法</h3><h5 id="currentThread-方法"><a href="#currentThread-方法" class="headerlink" title="currentThread()方法"></a>currentThread()方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> Thread <span class="title">currentThread</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>currentThread()方法可返回代码段正在被哪个线程调用的信息。</p><h5 id="isAlive-方法"><a href="#isAlive-方法" class="headerlink" title="isAlive()方法"></a>isAlive()方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isAlive</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>方法isAlive()的功能是判断当前的线程是否处于活动(除开TERMINATED)状态。</p><h5 id="join-方法"><a href="#join-方法" class="headerlink" title="join()方法"></a>join()方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span>;</span><br></pre></td></tr></table></figure><p>调用线程对象的join()方法后,当前线程从RUNNABLE切换到WAITING/TIMED_WAITING状态，直到线程对象的run执行完毕。</p><h5 id="sleep-方法"><a href="#sleep-方法" class="headerlink" title="sleep()方法"></a>sleep()方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span></span>;</span><br></pre></td></tr></table></figure><p>sleep()方法会释放cpu的时间片，但是不会释放锁，调用sleep()之后从RUNNABLE状态转为TIMED_WAITING状态</p><h5 id="yield-方法"><a href="#yield-方法" class="headerlink" title="yield()方法"></a>yield()方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>提示线程调度器当前线程愿意放弃当前CPU的使用。如果当前资源不紧张，调度器可以忽略这个提示。本质上线程状态一直是RUNNABLE,但是我可以理解为RUNNABLE到RUNNING的转换</p><hr><h3 id="线程优先级和守护线程"><a href="#线程优先级和守护线程" class="headerlink" title="线程优先级和守护线程"></a>线程优先级和守护线程</h3><h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><p>java中的线程优先级的范围是1～10，默认的优先级是5。每个线程默认的优先级都与创建它的父线程具有相同的优先级。默认情况下，mian线程具有普通优先级。“高优先级线程”会优先于“低优先级线程”执行。”高优先级线程”可能会优先于“低优先级线程”执行，Thread提供了<code>setPriority()</code>和<code>getPriority()</code>方法来设置和返回线程优先级。</p><p> Thread类有3个静态常量： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MAX_PRIORITY = 10</span><br><span class="line">MIN_PRIORITY = 1</span><br><span class="line">NORM_PRIORITY = 5</span><br></pre></td></tr></table></figure><hr><h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><ul><li><p>java 中有两种线程：用户线程和守护线程。可以通过<code>isDaemon()</code>方法来区别它们：如果返回false，则说明该线程是“用户线程”；否则就是“守护线程”。用户线程一般用户执行用户级任务，而守护线程也就是“后台线程”，一般用来执行后台任务，垃圾回收线程，就是最典型的守护线程。</p></li><li><p>所有的用户线程结束后，守护线程才会随之结束。</p></li><li><p>main线程是用户线程，main线程结束后，不会影响到其他用户线程。</p></li><li><p><code>setDaemon(true)</code>必须在调用线程的start()方法之前设置，否则会抛IllegalThreadStateException异常。</p></li><li><p>在守护线程中产生的新线程也是守护线程。 </p></li></ul><hr><h3 id="线程同步与线程安全"><a href="#线程同步与线程安全" class="headerlink" title="线程同步与线程安全"></a>线程同步与线程安全</h3><h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>CPU可能随机的在多个处于就绪状态中的线程中进行切换，就意味者一个线程并不是被执行完所有的语句之后才被切换的，所以多线程环境下对共享资源的访问可能会引起此共享资源的不一致性，这就是线程安全问题。为避免线程安全问题，应该避免多线程环境下对共享资源的并发访问。</p><hr><h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><p>java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（如数据的增删改查），将会导致数据不准确，相互之间产生冲突，因此加入同步机制以避免在该线程没有完成操作之前，被其他线程的调用，从而保证了该变量的唯一性和准确性。</p><h5 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h5><p>对共享资源进行访问的方法定义中加上synchronized关键字修饰，使得此方法称为同步方法。可以简单理解成对此方法进行了加锁，其锁对象为当前方法所在的对象自身。多线程环境下，当执行此方法时，首先都要获得此同步锁（且同时最多只有一个线程能够获得），只有当线程执行完此同步方法后，才会释放锁对象，其他的线程才有可能获取此同步锁，以此类推…。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="同步块"><a href="#同步块" class="headerlink" title="同步块"></a>同步块</h5><p>解决线程安全问题其实只需限制对共享资源访问的不确定性即可。使用同步方法时，使得整个方法体都成为了同步执行状态，会使得可能出现同步范围过大的情况，于是，针对需要同步的代码可以直接另一种同步方式——同步代码块来解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (obj) &#123;     </span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，obj为锁对象，因此，选择哪一个对象作为锁是至关重要的。一般情况下，都是选择此共享资源对象作为锁对象。</p><h5 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h5><p><strong>原理：</strong><br>在java中，每一个对象有且仅有一个同步锁。这也意味着，同步锁是依赖于对象而存在。当前线程调用某对象的synchronized方法时，就获取了该对象的同步锁。例如，synchronized(obj)，当前线程就获取了“obj这个对象”的同步锁。不同线程对同步锁的访问是互斥的。也就是说，某时间点，对象的同步锁只能被一个线程获取到。</p><hr><h4 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h4><p><strong>wait() / notify() / notifyAll()</strong> ：都是Object类的方法。</p><ul><li><p>wait()：导致当前线程等待并使其进入到等待阻塞状态。直到其他线程调用该同步锁对象的notify()或notifyAll()方法来唤醒此线程。</p></li><li><p>notify()：唤醒在此同步锁对象上等待的单个线程，如果有多个线程都在此同步锁对象上等待，则会任意选择其中某个线程进行唤醒操作，只有当前线程放弃对同步锁对象的锁定，才可能执行被唤醒的线程。</p></li><li><p>notifyAll()：唤醒在此同步锁对象上等待的所有线程，只有当前线程放弃对同步锁对象的锁定，才可能执行被唤醒的线程。</p></li></ul><p>1.<code>wait()</code>方法执行后，当前线程立即进入到等待阻塞状态，其后面的代码不会执行； </p><p>2.<code>notify()</code>/<code>notifyAll()</code>方法执行后，将唤醒此同步锁对象上的（任意一个-<code>notify()</code>/所有-<code>notifyAll()</code>）线程对象，但是，此时还并没有释放同步锁对象，也就是说，如果<code>notify()</code>/<code>notifyAll()</code>后面还有代码，还会继续执行，直到当前线程执行完毕才会释放同步锁对象；</p><p>3.<code>notify()</code>/<code>notifyAll()</code>执行后，如果下面有<code>sleep()</code>方法，则会使当前线程进入到阻塞状态，但是同步对象锁没有释放，依然自己保留，那么一定时候后还是会继续执行此线程，接下来同2；</p><p>4.<code>wait()</code>/<code>notify()</code>/<code>nitifyAll()</code>完成线程间的通信或协作都是基于相同对象锁的，因此，如果是不同的同步对象锁将失去意义，同时，同步对象锁最好是与共享资源对象保持一一对应关系；</p><p>5.当wait线程唤醒后并执行时，是接着上次执行到的<code>wait()</code>方法代码后面继续往下执行的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初学Java-网络编程</title>
      <link href="/2019/12/16/%E5%88%9D%E5%AD%A6Java-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2019/12/16/%E5%88%9D%E5%AD%A6Java-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>网络编程总结</p><a id="more"></a><h3 id="TCP-与-UDP-协议"><a href="#TCP-与-UDP-协议" class="headerlink" title="TCP 与 UDP 协议"></a>TCP 与 UDP 协议</h3><ul><li>TCP：<br>提供面向连接的服务，在传输数据之前必须先建立连接，数据传输之后要释放连接。流模式。</li><li>UDP：<br>在传输数据之前不建立连接，直接发送数据报到网络。数据报模式。<h3 id="套字节与端口"><a href="#套字节与端口" class="headerlink" title="套字节与端口"></a>套字节与端口</h3></li><li>套接字：<br>当两台计算机连接起来建立一个双向的通信链路时，这个双向通信链路的每一端称之为一个套接字（Socket）。</li><li>端口:<br>一台服务器上可能提供多种服务，使用 IP 地址只能唯一定位到某一台计算机，却不能准确地连接到想要连接的服务器。通常使用一个 0~65535 的整数来标识该机器上的某个服务，这个整数就是端口号（Port）。<h3 id="Java-InetAddress-类"><a href="#Java-InetAddress-类" class="headerlink" title="Java InetAddress 类"></a>Java InetAddress 类</h3>Internet 上的主机有两种方式表示地址，分别为域名和 IP 地址。java.net 包中的 InetAddress 类对象包含一个主机地址的域名和 IP 地址。 </li></ul><p><strong>InetAddress类的常用方法 ：</strong></p><ul><li>static InetAddress[] getAHByName(String host)<br>在给定主机名的情况下，根据系统上配置的名称，服务器返回其 IP 地址所组成的数组</li><li>static InetAddress getByAddress(String host)<br>在给定主机名的情况下确定主机的 IP 地址</li><li>String getHostAddress()<br>返回 IP 地址字符串（以文本表现形式）</li><li>String getHostName()<br>返回此 IP 地址的主机名</li><li>static InetAdderss getLocalHost()<br>返回本地主机</li></ul><h3 id="Java-TCP通信"><a href="#Java-TCP通信" class="headerlink" title="Java TCP通信"></a>Java TCP通信</h3><p>TCP 网络程序是指利用 Socket 编写的通信程序。利用 TCP 协议进行通信的两个应用程序是有主次之分的，一个是服务器程序，一个是客户端程序，两者的功能和编写方法不太一样。其中 ServerSocket 类表示 Socket 服务器端，Socket 类表示 Socket 客户端。Socket 类表示 Socket 客户端，两者之间的交互过程如下：</p><ol><li>服务器端创建一个 ServerSocket （服务器端套接字），调用 accept() 方法等待客户端来连接。</li><li>客户端程序创建一个 Socket，请求与服务器建立连接。</li><li>服务器接收客户端的连接请求，同时创建一个新的 Socket 与客户端建立连接，服务器继续等待新的请求。</li></ol><h4 id="ServerSocket-类"><a href="#ServerSocket-类" class="headerlink" title="ServerSocket 类"></a>ServerSocket 类</h4><p>ServerSocket 类是与 Socket 类相对应的用于表示通信双方中的服务器端，用于在服务器上开一个端口，被动的等待数据（使用accept() 方法）并建立连接进行数据交互。<br>服务器套接字一次可与一个套接字连接，如果多台客户端同时提出连接请求，服务器套接字会将请求连接的客户端存入队列中，然后从中取出一个套接字与服务器新建的套接字连接起来，若请求连接大于最大容纳数，则多出的连接请求被拒绝；默认的队列大小是50。</p><p><strong>ServerSocket 类常用方法：</strong></p><ul><li>Server accept()：监听要连接到此套接字并接受它。 </li><li>void close()：关闭此套接字。</li></ul><p>调用 accept() 方法会返回一个和客户端 Socket 对象相连接的 Socket 对象</p><p>** 使用 ServerSocket 类创建一个使用端口 8888 的服务器端套接字，如下：**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//在8888端口创建一个服务器端套接字</span></span><br><span class="line">        ServerSocket s_socket = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        System.out.println(<span class="string">"服务器端 Socket 套接字创建成功！"</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123; </span><br><span class="line">            System.out.println(<span class="string">"等待客户端的连接请求!"</span>);</span><br><span class="line">            <span class="comment">//等待客户端的连接请求</span></span><br><span class="line">            Socket socket = s_socket.accept(); </span><br><span class="line">            <span class="comment">//阻塞式创建连接</span></span><br><span class="line">            <span class="comment">//如果没有客户端的连接请求，则 accept() 方法为空，</span></span><br><span class="line">            <span class="comment">//所以不会输出“成功建立与客户端的连接”</span></span><br><span class="line">            System.out.println(<span class="string">"成功建立与客户端的连接!"</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//从客户端接收数据</span></span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        in = socket.getInputStream();</span><br><span class="line">        <span class="keyword">int</span> len = in.read(b);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//将数据发送到客户端</span></span><br><span class="line">            out = socket.getOutputStream();<span class="comment">//发送数据</span></span><br><span class="line">            out.write(<span class="string">"欢迎登陆到客户端！"</span>.getBytes());</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Socket-类"><a href="#Socket-类" class="headerlink" title="Socket 类"></a>Socket 类</h4><p>Socket 类表示通信双方中的客户端，用于呼叫远端机器上的一个端口，主动向服务器端发送数据（当连接建立后也能接收数据）</p><p><strong>Socket类构造方法</strong></p><ul><li>Socket(InetAddress address,int port)：<br>创建一个流套接字并将其连接到指定 IP 地址的指定端口。</li></ul><p><strong>Socket 类常用方法：</strong></p><ul><li>void close()：<br>关闭此套接字。</li><li>InputStream getInputStream()：<br>返回此套接字的输入流。</li><li>OutputStream getOutputStream()：<br>返回此套接字的输出流。</li></ul><p><strong>使用Socket类创建客户端套接字，和服务器端完成简单的通信：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.定义 Socket 对象、OutputStream 对象和一个 InputStream 对象并完成初始化</span></span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream out = <span class="keyword">null</span>;</span><br><span class="line">        InputStream in = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//定义服务器端的 IP 地址和端口号</span></span><br><span class="line">        String serverIP = <span class="string">"127.0.0.1"</span>;<span class="comment">//服务器端 IP 地址</span></span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">8888</span>;<span class="comment">//服务器端端口号</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//2.建立与服务器端的连接并将数据发送到服务器端</span></span><br><span class="line">            socket = <span class="keyword">new</span> Socket(serverIP, port);<span class="comment">//建立连接</span></span><br><span class="line">            out = socket.getOutputStream();<span class="comment">//发送数据</span></span><br><span class="line">            out.write(<span class="string">"我是客户端数据"</span>.getBytes());</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//3.从输入流中读出服务器的反馈信息并输出到控制台</span></span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            in = socket.getInputStream();</span><br><span class="line">            <span class="keyword">int</span> len = in.read(b);</span><br><span class="line">            System.out.println(<span class="string">"服务器端的反馈为："</span> + <span class="keyword">new</span> String(b, <span class="number">0</span>, len));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//4.关闭流及 Socket 对象</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                in.close();</span><br><span class="line">                out.close();</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java-UDP通信"><a href="#Java-UDP通信" class="headerlink" title="Java UDP通信"></a>Java UDP通信</h3><p>虽然 UDP 协议是一种不太可靠的协议，但有时在需要较快地接收数据并且可以忍受较小错误的情况下，UDP就会表现出更大的优势。</p><p><strong>使用 UDP 协议发送数据的步骤：</strong></p><ul><li>使用 DatagramSocket() 创建一个数据包套接字。</li><li>使用 DatagramPacket() 创建要发送的数据包。</li><li>使用 DatagramSocket 类的 send() 方法发送数据包。</li></ul><p><strong>接收 UDP 数据包的步骤：</strong></p><ul><li>使用 DatagramSocket 创建数据包套接字，并将其绑定到指定的端口。</li><li>使用 DatagramPacket 创建字节数组来接收数据包。</li><li>使用 DatagramPacket 类的 receive() 方法接收 UDP 包</li></ul><h4 id="DatagramPacket类"><a href="#DatagramPacket类" class="headerlink" title="DatagramPacket类"></a>DatagramPacket类</h4><p>DatagramPacket 类用来表示数据报包，数据报包用来实现无连接包投递服务。每条报文仅根据该包中包含的信息从一台机器路由到另一台机器。从一台机器发送到另一台机器的多个包可能选择不同的路由，也可能按不同的顺序到达。</p><h4 id="DatagramSocket-类"><a href="#DatagramSocket-类" class="headerlink" title="DatagramSocket 类"></a>DatagramSocket 类</h4><p>DatagramSocket 类用于表示发送和接收数据报包的套接字。数据报包套接字是包投递服务的发送或接收点。每个在数据报包套接字上发送或接收的包都是单独编址和路由的。</p><p><strong>UDP通信客户端/服务端：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="comment">//1.使用DatagramSocket 指定端口 创建接收端/服务端  端口号不能相同</span></span><br><span class="line">DatagramSocket socket = <span class="keyword">new</span> DatagramSocket(<span class="number">8888</span>); </span><br><span class="line"><span class="comment">//  2.准备数据，接收方的地址(ip,端口)</span></span><br><span class="line">    SocketAddress address = <span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>,<span class="number">9999</span>);</span><br><span class="line">    <span class="keyword">byte</span>[] datas = <span class="string">"发送数据****"</span>.getBytes();</span><br><span class="line"><span class="comment">//3.封装成DatagramPacekt包裹，需要指定目的地 </span></span><br><span class="line">DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(datas,<span class="number">0</span>,datas.length,address); </span><br><span class="line">    <span class="comment">//  4.发送数据包</span></span><br><span class="line">    socket.send(packet);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  5.准备空间接收数据包(数据包最大60K)</span></span><br><span class="line">    <span class="keyword">byte</span>[] container = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">60</span>];</span><br><span class="line">    <span class="comment">//  6.构造 DatagramPacket，用来接收长度为 length 的数据包</span></span><br><span class="line">DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(container,container.length);</span><br><span class="line"><span class="comment">// * 5.阻塞式接收包裹receive(DatagramPacekt)</span></span><br><span class="line">server.receive(packet);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭 DatagramSocket 对象</span></span><br><span class="line">    server.colse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初学java-IO</title>
      <link href="/2019/12/13/%E5%88%9D%E5%AD%A6java-IO/"/>
      <url>/2019/12/13/%E5%88%9D%E5%AD%A6java-IO/</url>
      
        <content type="html"><![CDATA[<p>特地对java的IO做一个总结</p><a id="more"></a><h2 id="IO概述"><a href="#IO概述" class="headerlink" title="IO概述"></a>IO概述</h2><ul><li>IO中最重要的5个类和1个接口：<strong>File、OutputStream、InputStream、Writer、Reader；Serializable.</strong></li></ul><h2 id="io体系"><a href="#io体系" class="headerlink" title="io体系"></a>io体系</h2><p>从操作方向(<strong>代码的角度</strong>)来看，IO类可以分为：</p><ul><li>输入流：读取/输入数据 到代码</li><li>输出流：把代码的数据 写出/输出</li></ul><hr><p>从操作类型来看，IO类可以分为：</p><ul><li>字节流 : 字节流可以操作任何数据(文本，图片，视频)，因为所有的数据都是以字节的形式存储。</li><li>字符流 : 字符流只能操作字符数据。</li></ul><p><em>Q: 字符在计算机中是怎么表示的？</em><br><em>A：将字符是按照规则翻译对应的二进制数(编码)，一个字符通常用多个字节存储。</em></p><p><em>Q: 字节流可以操作字符数据吗？</em><br><em>A：”字节流可以操作任何数据 “，是可以操作的，但是。。。</em></p><p><em>Q: 字节流可以操作任何数据，为什么还需要字符流？</em><br><em>A：字节流处理文本文件会出现乱码问题(字节流不编码&amp;解码)，所以需要字符流来处理文本文件。</em></p><p><em>Q：那我就是想用字节流处理文本文件，咋办呢？</em><br><em>A：你自己用代码去编码，解码就可以了。</em></p><p><em>Q：那既然有字符流，为啥没有图片流，音频流，视频流？</em><br><em>A：emmm,我等下去问问老师。</em></p><p><em>Q：那什么时候用字符流，什么时候用字节流啊？</em><br><em>A：处理文本文件用字符流，其他的用字节流。</em></p><hr><p>从操作对象来看，IO类可以分为：</p><ul><li><p>文件(节点流)：对文件进行读取、写入操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream, FileOutputStream</span><br><span class="line">FileWriter, FileReader</span><br></pre></td></tr></table></figure></li><li><p>数组(节点流)：对数组进行读取、写入操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteArrayInputStream, ByteArrayOutputStream</span><br><span class="line">CharArrayReader, CharArrayWriter</span><br></pre></td></tr></table></figure></li><li><p>管道操作(节点流)：实现管道的输入和输出（线程间通信）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PipedInputStream, PipedOutputStream</span><br><span class="line">PipedReader, PipedWriter</span><br></pre></td></tr></table></figure></li><li><p>缓冲操作(处理流)：在读入或写出时，对数据进行缓存，以减少I/O的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BufferedInputStream, BufferedOutputStream</span><br><span class="line">BufferedReader, BufferedWriter</span><br></pre></td></tr></table></figure></li><li><p>字节转换字符(处理流)：按照一定的编码/解码标准将字节流转换为字符流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader、OutputStreWriter</span><br></pre></td></tr></table></figure></li><li><p>打印(处理流)：包含方便的打印方法 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PrintStream、PrintWriter</span><br></pre></td></tr></table></figure></li><li><p>基本数据类型(处理流)：允许应用程序以与机器无关方式从底层输入流中读写基本 Java 数据类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataInputStream、DataOutputStream</span><br></pre></td></tr></table></figure></li><li><p>对象序列化反序列化(处理流)：保存在内存中的各种对象的状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream、ObjectOutputStream</span><br></pre></td></tr></table></figure></li></ul><p><strong>节点流：程序用于直接操作目标设备所对应的类</strong><br><strong>处理流：程序通过一个间接流类去调用节点流类，以达到更加灵活方便地读写各种类型的数据</strong><br><strong>节点流是一杯原味咖啡的话，处理流就是各种配料，让节点流更好喝</strong></p><p><em>Q：处理流要怎么使用呢？</em><br><em>A：实例化处理流类的时候要给一个节点流对象，</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader());</span><br><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream());</span><br></pre></td></tr></table></figure><p><em>Q：为什么不直接操作数组，而用内存数组流呢？</em><br><em>A：数组是基本数据类型，而内存数组流是类，就和有<code>int</code>但是还有Integer类是一样的。</em></p><p><em>Q：管道是啥啊？</em><br><em>A：emmm,我也不懂，等我学会了再告诉你……</em></p><p><em>Q：什么情况下用缓存流啊？</em><br><em>A：缓存流可以优化性能，看到文件流和数组流就套上去。但是没必要套几个缓存流，一个就够了。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader());</span><br></pre></td></tr></table></figure><p><em>Q：什么情况下用字节转换字符流啊？</em><br><em>A：<code>FileReader</code>和 <code>FileWriter</code>的<strong>字符编码</strong>是IDEA的设置，要使用别的<strong>字符编码</strong>，就用字节转换字节流。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(),<span class="string">"GBK"</span>);</span><br></pre></td></tr></table></figure><p><em>Q：打印流可以用来辅助输入流吗？</em><br><em>A：不可以，打印流只能为其他输出流添加功能。所以打印流永远不会抛出IO异常。</em></p><p><em>Q：<code>PrintStream</code>和 <code>PrintWriter</code>有么区别啊？</em><br><em>A：<code>PrintStream</code>和 <code>PrintWriter</code>中的方法是一样的，但是 <code>PrintWriter</code>的构造方法比 <code>PrintStream</code>多了一个接收 字符流 的构成方法( <code>PrintWriter</code>比 <code>PrintStream</code>灵活)，所以掌握 <code>PrintWriter</code>就可以了</em></p><p><em>Q：基本数据类型流是的功能好像不是很有用唉！</em><br><em>A：有用的很！用 <code>FileOutputStream</code>写入一个<code>int</code>类型的数据到文件，只会写入最低位，。而用 <code>DataOutputStream</code>就能避免这样的情况。</em></p><p><em>Q：那使用基本数据类型流有什么要注意的？</em><br><em>A：读取数据的顺序一定要和写入的顺序一致。</em></p><p><em>Q：所以的对象都可以通过序列化保持下来吗？</em><br><em>A：只要该类实现了 <code>java.io.Serializable</code>接口，都可以序列化或者反序列化。如果有属性不需要序列化，可以用 <code>transient</code>关键字修饰。</em></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown命令</title>
      <link href="/2019/11/17/%E5%B8%B8%E7%94%A8Markd%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/11/17/%E5%B8%B8%E7%94%A8Markd%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>记录一些常用的Markdown语法。</p><a id="more"></a><h2 id="mermaid"><a href="#mermaid" class="headerlink" title="mermaid"></a>mermaid</h2><p>语法框架：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">```mermaid</span><br><span class="line">    ……流程图代码……</span><br><span class="line">```</span><br></pre></td></tr></table></figure><hr><p>起始代码：<br>graph &lt;布局方向&gt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>TB（Top Bottom）表示从上向下布局<br>BT（Bottom Top）表示从下向下布局<br>LR（Left Right）表示从左向右布局<br>RL（Right Left）表示从右向左布局</p>]]></content>
      
      
      
        <tags>
            
            <tag> 常用命令 </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo命令</title>
      <link href="/2019/11/17/Hexo%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/11/17/Hexo%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>记录一些常用的Hexo命令。</p><a id="more"></a><h3 id="hexo-s"><a href="#hexo-s" class="headerlink" title="hexo s"></a>hexo s</h3><p><code>hexo s</code></p><ul><li>启动本地服务器，用于预览主题。默认地址： <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></li><li>hexo s 是 hexo server 的缩写，命令效果一致；</li><li>预览的同时可以修改文章内容或主题代码，保存后刷新页面即可；</li><li>对 Hexo 根目录 _config.yml 的修改，需要重启本地服务器后才能预览效果。</li></ul><hr><h3 id="hexo-new"><a href="#hexo-new" class="headerlink" title="hexo new"></a>hexo new</h3><p><code>hexo new &quot;常用hexo语法 一&quot;</code></p><ul><li>新建一篇标题为 常用hexo命令 一 的文章，因为标题里有空格，所以加上了引号。</li><li>文章标题可以在对应 md 文件里改，新建时标题可以写的简单些。</li></ul><hr><h3 id="hexo-d"><a href="#hexo-d" class="headerlink" title="hexo d"></a>hexo d</h3><p><code>hexo d</code></p><ul><li><p>自动生成网站静态文件，并部署到设定的仓库。</p></li><li><p>hexo d 是 hexo deploy 的缩写，命令效果一致。</p></li></ul><hr><h3 id="hexo-clean"><a href="#hexo-clean" class="headerlink" title="hexo clean"></a>hexo clean</h3><p><code>hexo clean</code></p><ul><li>清除缓存文件 db.json 和已生成的静态文件 public 。</li><li>网站显示异常时可以执行这条命令试试。</li></ul><hr><h3 id="hexo-g"><a href="#hexo-g" class="headerlink" title="hexo g"></a>hexo g</h3><p><code>hexo g</code></p><ul><li>生成网站静态文件到默认设置的 public 文件夹。</li><li>便于查看网站生成的静态文件或者手动部署网站；</li><li>如果使用自动部署，不需要先执行该命令；</li><li>hexo g 是 hexo generate 的缩写，命令效果一致。</li></ul><hr><h3 id="hexo-new-page"><a href="#hexo-new-page" class="headerlink" title="hexo new page"></a>hexo new page</h3><p><code>hexo new page aboutme</code></p><ul><li>新建一个标题为 aboutme 的页面，默认链接地址为 主页地址/aboutme/</li><li>标题可以为中文，但一般习惯用英文；</li><li>页面标题和文章一样可以随意修改；</li><li>页面不会出现在首页文章列表和归档中，也不支持设置分类和标签。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 常用命令 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
